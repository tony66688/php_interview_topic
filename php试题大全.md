## Session 与 cookie 的区别

> 1. cookie 数据存放在客户的浏览器上，session 数据放在服务器上，以文件的形式存放，可以从 php.ini 里面的 session.save_path 找到存放位置
> 2. cookie 不是很安全 ，cookie 可以进行 cookie 欺骗，别人可以获取 cookie 中的 session id 考虑到安全应当使用 session。
> 3. session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
> 4. 考虑到减轻服务器，性能方面，应当使用 COOKIE。
> 5. 单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。
> 6. 所以个人建议：将登陆信息等重要信息存放为 SESSION 其他信息如果需要保留，可以放在 COOKIE 中



**什么是 Session？**

> - Session 是另一种记录客户状态的机制，不同的是 Cookie 保存在客户端浏览器中，而 Session 保存在服务器上。
> - 客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。
> - 这就是 Session。客户端浏览器再次访问时只需要从该 Session 中查找该客户的状态就可以了。

------

**. 什么是 Cookie？**

> - Cookie 意为 “甜饼”，是由 W3C 组织提出，最早由 Netscape 社区发展的一种机制。
> - 目前 Cookie 已经成为标准，所有的主流浏览器如 IE、Netscape、Firefox、Opera 等都支持 Cookie。
> - 由于 HTTP 是一种无状态的协议，服务器单从网络连接上无从知道客户身份。
> - 怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。
> - 这样服务器就能从通行证上确认客户身份了。这就是 Cookie 的工作原理。
> - Cookie 实际上是一小段的文本信息。
> - 客户端请求服务器，如果服务器需要记录该用户状态，就使用 response 向客户端浏览器颁发一个 Cookie。
> - 客户端浏览器会把 Cookie 保存起来。
> - 当浏览器再请求该网站时，浏览器把请求的网址连同该 Cookie 一同提交给服务器。
> - 服务器检查该 Cookie，以此来辨认用户状态。服务器还可以根据需要修改 Cookie 的内容。

------

**Session 的优缺点？**
`优点`

> - 如果要在诸多 Web 页间传递一个变量，那么用 Session 变量要比通过 QueryString 传递变量可使问题简化。
> - 要使 WEb 站点具有用户化，可以考虑使用 Session 变量。
> - 你的站点的每位访问者都有用户化的经验，基于此，随着 LDAP 和诸如 MS Site Server 等的使用，已不必再将所有用户化过程置入 Session 变量了，而这个用户化是取决于用户喜好的。
> - 你可以在任何想要使用的时候直接使用 session 变量，而不必事先声明它，这种方式接近于在 VB 中变量的使用。
> - 使用完毕后，也不必考虑将其释放，因为它将自动释放。

```
缺点
```

> - Session 变量和 cookies 是同一类型的。
> - 如果某用户将浏览器设置为不兼容任何 cookie，那么该用户就无法使用这个 Session 变量！
> - 当一个用户访问某页面时，每个 Session 变量的运行环境便自动生成，这些 Session 变量可在用户离开该页面后仍保留 20 分钟！（事实上，这些变量一直可保留至 “timeout”。“timeout” 的时间长短由 Web 服务器管理员设定。一些站点上的变量仅维持了 3 分钟，一些则为 10 分钟，还有一些则保留至默认值 20 分钟。）所以，如果在 Session 中置入了较大的对象（如 ADO recordsets，connections， 等等），那就有麻烦了！随着站点访问量的增大，服务器将会因此而无法正常运行！
> - 因为创建 Session 变量有很大的随意性，可随时调用，不需要开发者做精确地处理，所以，过度使用 session 变量将会导致代码不可读而且不好维护。

```
Cookie的优缺点？
优点
```

> - 极高的扩展性和可用性
> - 通过良好的编程，控制保存在 cookie 中的 session 对象的大小。
> - 通过加密和安全传输技术（SSL），减少 cookie 被破解的可能性。
> - 只在 cookie 中存放不敏感数据，即使被盗也不会有重大损失。
> - 控制 cookie 的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的 cookie。

```
缺点
```

> - Cookie 数量和长度的限制。
> - 每个 domain 最多只能有 20 条 cookie，每个 cookie 长度不能超过 4KB，否则会被截掉。
> - 安全性问题。如果 cookie 被人拦截了，那人就可以取得所有的 session 信息。即使加密也与事无补，因为拦截者并不需要知道 cookie 的意义，他只要原样转发 cookie 就可以达到目的了。
> - 有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。

```
使用场景
```

> - cookie 用于存放前台临时内容，比如 sessionid，购物车业务中的商品信息，使用容易被窃取。
> - Session 用于存放后台的用户信息跟 cookie 进行会话机制，用于系统登录业务逻辑

```
作用
```

> - cookie 的作用是解决 HTTP 协议中缺少无状态缺陷的问题
> - 由于 cookie 是在客户端，并不安全，另外如果浏览器禁用了 cookie 也会导致会话记录失败.
> - 而 session 存储在服务器，是相对安全的。由服务端很方便控制存储到各种介质中.
> - php 的 php.ini 配置文件里可以设置 session 的路径和回收空置率的.

```
Cookie被禁用session能否使用？
```

> Cookie 被禁用时并不影响 session 的使用，只不过 coookie 不能存放 sessionid 而已，可以使用 hidden 隐藏区域存放

------

## Token 的作用？

> Token 学名就是令牌，就是定于验证码，比如网站后台使用时间戳 md5 加密每 20 加密一次存放在 cookie，或者前端中，当前端与后台进行通信时在验证这个自定义的验证码是否于后。 台的验证码一致，如果一致为正常，如果不一致则为恶意攻击

------

## 什么是 Xss 攻击？怎么防止？

```
什么是Xss攻击
```

> Xss 又称 css，全称：跨站式脚本攻击，问题出现的原因：用户在输入内容时故意输入 css 或者 js 代码使网站在加载内容时运行恶意程序造成网站无法正常运行或者恶意盗取信息

```
防止
```

> 1. 正则过滤特殊字符，比如 < > = ‘’
> 2. 去除 html 标签 strp_tags ()
> 3. 利用 php 函数特殊字符转义 htmlentities () addslashes（）

------

## Php 数据类型有那些？

> - 4 种标量 int 整型 float 浮点型 boolean 布尔型 string 字符串型
> - 2 种复合 object 对象 array 数组
> - 2 种资源 null 空 resource 资源

------

## Php 运行模式？如何运行？

Nignx+php `fast cgi`
命令行模式 `cli`
Apache+php `web模式`
Iss+php `ISAPI模式`
老版本的 nginx+php `cgi`

```
Fastcgi运行机制
```

> cgi 的升级版，多进程，说明 cgi 每次运行都需要加载 php.ini 等配置文件，所以速度慢，而 fastcgi 父进程加载一次，子进程不需要加载，所以速度快。

```
Web模块运行机制
```

> 是以 php 的扩展形式安装在 apache 下当需要解析 php 代码时，则直接调用 php 扩展功能。

```
cLi命令行模式
```

> 就是直接运行在命令行，linux 和 windos 都支持

```
ISAPI模式
```

> 是 IIS 微软操作系统自带的 web 服务器把 php 源码发给 php 进行解析

------

## Php-fpm 是什么？php-fpm 与 ningx 如何交互？

```
是什么
```

> - Php-fpm 是 php 的进程管理器，f 代表 fast-cgi,p 代表 process,m 代表 manager
> - Php-fpm 是 fast –cgI 进程管理器，他是对于 fast ci 协议的具体实现他负责管理一个进程池，来处理 web 服务器的请求，在 php5.3 版本以后，php-fpm 是内置与 php 中。

```
如何交互
```

> fpm 默认通过监听 9000 端口，当请求到 nginx web 服务器时，nginx 打开相应地址下的 php 文件把源码通过 9000 端口发送到 php-fpm，php-fpm 再把源码通过 php 进程进行解析源码，把结果返回到 ningx 在返回客户端。

------

## php 是单继承还是多继承？如何实现多继承？

> - PHP 类不支持多继承，也就是子类只能继承一个父类，但是接口可以实现多继承，可以继承一个或者多个接口。当然接口的继承也是和类的继承一样使用 extends 关键字，要多个继承的话只要用逗号把继承的接口隔开即可。
> - 自 PHP 5.4.0 起，PHP 实现了一种代码复用的方法，称为 `trait`。`Trait` 是为类似 PHP 的单继承语言而准备的一种代码复用机制。Trait 和 Class 相似，`Trait` 可以理解为一组能被不同的类都能调用到的方法集合，但 `Traits` 不是类！不能被实例化.

------

## Git merge 与 git rebsae 的区别？，git pull 与 git fetch 的区别？

- > Git merge 是多分支合并，按时间顺序排序，比如主分支有历史版本是前天，今天，二从分支只有昨天，则合并后历史版本是前天，昨天，今天

- > Git rebase 多分支合并时，时间有的时候会缺失，并且把当前的分支历史版本放在别合并的历史版本后面座位最新版本，则合并后的历史版本是，前天，今天，昨天。

- > git pull 是把拉下的分支内容与当前分支进行权柄，

- > git fetch 只把数据拉下来并不合并。Git pull = git fetch+git merge

------

## 原生 php 如何动态获取函数参数个数，参数列表与参数值？

> - func_num_args — 返回传入函数的参数总个数
> - func_get_args — 返回传入函数的参数列表
> - func_get_arg — 根据参数索引从参数列表返回参数值

------

## mysql 数据库怎么备份？

> - 备份数据库 mysqldump 数据库名 > sql
> - 备份数据表 mysqldump -uroot -p -B 数据库名 –table 表名
> - 导入数据库 mysqldump –uroot -p 数据库，名 < sql

------

## 常见的魔术类方法？分别是什么时候触发？

> - __construct 构造函数 初始化赋值 实例化对象的时候自己调用
> - __destruct 析构方法，PHP 将在对象被销毁前（即从内存中清除前）调用这个方法
> - __get ($property) 当调用一个未定义的属性时，此方法会被触发，传递的参数是被访问的属性名
> - __set ($property, $value) 给一个未定义的属性赋值时，此方法会被触发，传递的参数是被设置的属性名和值 这里的没有声明包括当使用对象调用时，访问控制为 proteced,private 的属性（即没有权限访问的属性）。
> - __isset ($property) 当在一个未定义的属性上调用 isset () 函数时调用此方法
> - __unset ($property) 当在一个未定义的属性上调用 unset () 函数时调用此方法
> - _call ($method, $arg_array) 当调用一个未定义的方法是调用此方法
> - __autoload 函数，它会在试图使用尚未被定义的类时自动调用。通过调用此函数，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。
> - **clone 复制一个对象时自动调用 clone 方法，如果在对象复制需要执行某些初始化操作，可以在** clone 方法实现。
> - __toString 方法在将一个对象转化成字符串时自动调用，比如使用 echo 打印对象时。
> - __sleep 串行化的时候用
> - __wakeup 反串行化的时候调用 _invoke
> - **invoke 当尝试以调用函数的方式调用一个对象时，**invoke 方法会被自动调用。
> - **callStatic 它的工作方式类似于** call () 魔术方法，__callStatic () 是为了处理静态方法调用

------

## 什么是 rest api？

> - 一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。
> - 它主要用于客户端和服务器交互类的软件。
> - 基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。每一个 URI 代表一种资源；

------

## 什么是 json？json 支持那些数据类型？

```
什么是josn
```

> - JSON (JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。
> - 它基于 ECMAScript (欧洲计算机协会制定的 js 规范) 的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。
> - 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。
> - JSON 具有自我描述性，更易理解
> - JSON 比 XML 更小、更快，更易解析。

```
数据格式
```

> 数字（整数或浮点数）
> 字符串（在双引号中）
> 布尔（true 或 false ）
> 数组（在方括号中）
> 对象（在花括号中）
> null

------

## 简述 php 的垃圾回收机制是如何实现的？

> - 简称 gc，PHP 使用了引用计数机制来回收。
> - 每个对象都内含一个引用计数器，每个 reference 链接到对象，计数器加 1，当 reference 离开对象被设为 null, 计数器减 1，当某个引用计数器的对象为 0 时，PHP 知道你将不再需要使用这个对象，释放其所占有的内存空间
> - 简单来说就是：在 PHP 中，没有任何变量指向一个对象的时侯，这个对象就成为垃圾。

------

## 写出构造方法的两种表现形式和析构函数的作用？

> - 构造方法的两种表现形式：__construct (){} 类名 (){}
> - 析构函数的作用：是对象被销毁时被调用，作用是释放内存 (__destruct ())

------

## 请分别写出定义常量和静态常量的区别？

> - 定义常量：使用 define () 函数 - 它使用三个参数：
>
>   1. > 首个参数定义常量的名称
>
>   2. > 第二个参数定义常量的值
>
>   3. > 可选的第三个参数规定常量名是否对大小写不敏感。默认是 false
>
> - 静态常量：静态常量，一般用 const 修饰

------

## 请简述 http 和 https 的区别？

```
区别
```

> - http 的 URL 以 http:// 开头，https 以 https:// 开头。
> - http 标准端口是 80 ，https 是 443。
> - https 协议需要到 ca 申请证书，http 不需要。
> - http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。
> - http 的连接很简单，是无状态的，https 协议是由 SSL+http 协议构建的可进行加密传输、身份认证的网络协议 要比 http 协议安全。

```
优点：
```

> 1. 通过证书可以更信任服务器。
> 2. 更安全，防篡改。

```
缺点：
```

> 1. https 需要证书。
> 2. 因为对传输进行加密，会一定程度增加 cpu 消耗。
> 3. 由于 https 要还密钥和确认加密算法的需要，所以首次建立连接会慢一些。
> 4. 带宽消耗会增加。

------

## 简述 composer 的原理？以及 composer include composer install composer require 的区别？

> - composer 是 PHP5.3 以上 的一个依赖管理工具。
> - 它允许你声明项目所依赖的代码库，它会在你的项目中为你安装他们。Composer 不是一个包管理器。
> - 是的，它涉及 "packages" 和 "libraries"，但它在每个项目的基础上进行管理，在你项目的某个目录中（例如 vendor）进行安装。
> - 默认情况下它不会在全局安装任何东西。因此，这仅仅是一个依赖管理
> - composer install 命令从当前目录读取 composer.json 文件，处理了依赖关系，并把其安装到 vendor 目录下
> - composer update 为了获取依赖的最新版本，并且升级 composer.lock 文件
> - composer require 指定下载的版本

------

## 数组实现队列用那些函数？

> - PHP 的数组处理函数还可以将数组实现队列，堆栈是 “先进后出”。在堆栈中，最后压入的数据（进栈），将会被最先弹出（出栈）。而队列是先进先出，就如同银行的排号机
> - 而 PHP 中，将数组当作是队列则主要是用 array_push () 和 array_shift () 实现
> - 出栈主要是利用 array_shift () 函数将数组的第一个元素弹出，并将数组的长度减 1

------

## Php 的工作原理？

PHP 的所有应用程序都是通过 WEB 服务器 (如 IIS，Nginx 或 Apache) 和 PHP 引擎程序解释执行完成的
`工作过程`

> (1) 当用户在浏览器地址中输入要访问的 PHP 页面文件名，然后触发一个 web 请求，并将请求传送到 WEB 服务器。
> (2) WEB 服务器接受这个请求，并根据其后缀进行判断是一个 PHP 请求，WEB 服务器从硬盘或内存中调出用户要访问的 PHP 应用程序，并将其发送给 PHP 引擎程序。
> (3) PHP 引擎程序将会对 WEB 服务器传送过来的文件从头到尾进行扫描并根据命令从后台读取，处理数据，并动态地生成相应的 HTML 页面。
> (4) PHP 引擎将生成 HTML 页面返回给 WEB 服务器。WEB 服务器再将 HTML 页面返回给客户端浏览器。

------

## 什么是类，什么是抽象类，什么是接口，什么是继承？

```
类的概念
```

> - 类是具有相同属性和行为的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，其内部包括属性和行为两个主要部分。
> - 举例：类就好比人类，类有各种属性和各种方法，就像每个人类有姓名，年龄，身高，体重等属性，也有吃饭，睡觉，走路等，具有相同的行为，所以，人构成一个类，即人类。
> - 使用的关键词是 class。

```
抽象类
```

> - 抽象就是不具体，不能实例化成具体的实例，可以理解成类的模板，定义为抽象的类不能被实例化。
> - 在任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象类，否则会报错。
> - 被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。使用 “abstract” 修饰

```
接口
```

> - 我们可以通过 interface 来定义一个接口，就像定义一个标准的类一样，但其中定义所有的方法都是空的。
> - 使用接口（interface），你可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。
> - 接口中定义的所有方法都必须是 public，这是接口的特性。

```
实现接口
```

> - 要实现一个接口，可以使用 implements 操作符。类中必须实现接口中定义的所有方法，否则 会报一个 fatal 错误。如果要实现多个接口，可以用逗号来分隔多个接口的名称。
> - 实现多个接口时，接口中的方法不能有重名。
> - 接口也可以继承，通过使用 extends 操作符。
> - 接口中也可以定义常量。接口常量和类常量的使用完全相同。 它们都是定值，不能被子类或子接口修改。

```
继承
```

> Php 单继承，PHP 类不支持多继承，也就是子类只能继承一个父类，但是支持多层次继承。

```
概念 关键词
```

> 父类只是一个平常的类，要想有后代你只需要在平常类后加一个 extends 关键字就可以继承，这样子类只拥有了父类所有的属性和方法。

```
继承权限问题
```

> - 父类 private 方法不可被继承，父类私有化
> - 父类 protected 方法可以被继承，但不能被实例化对象调用，父类对此方法置于保护模式下
> - 父类 public 方法可以被继承、可以被实例化对象调用，属于公开方法
> - 子类可重写父类 public 或者 protected 的方法，不能重写 private 的方法，如果同名只是在本类重新声明

------

## Include,require,include_once,require_once 的区别？

```
include与require的区别
```

> - include 与 require 除了在处理引入文件的方式不同外，
> - 最大的区别就是：include 在引入不存文件时产生一个警告且脚本还会继续执行， require 在引入不存文件则会导致一个致命性错误且脚本停止执行。

```
include_once与require_once的区别
```

> include_once,require_once 函数的作用与 include 相同，不过它会首先验证是否已包含该文件。如果已经包含，则不再执行 include_once。其他同 include 一样。

------

## ajax 的优点

> - 最大的一点是页面无刷新，在页面内与服务器通信，给用户的体验非常好。
> - 使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。
> - 可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，
> - 基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。

------

```
ajax的缺点
```

> - ajax 干掉了 back 按钮，即对浏览器后退机制的破坏
> - 安全问题因为 ajax 技术就像是直接建立一个通道，会暴露比以前数据和服务器逻辑
> - 对搜索引擎的支持比较弱
> - 一些手机设备现在还不能更好的支持 ajax

------

## 简述 DOM 加载顺序和常用的事件

```
DOM加载顺序
```

> \1. 解析 HTML 结构。
> \2. 加载外部脚本和样式表文件。
> \3. 解析并执行脚本代码。
> \4. 构造 HTML DOM 模型。
> \5. 加载图片等外部文件。
> \6. 页面加载完毕

`焦点事件`：当元素获得焦点或失去焦点时触发

> - blur：失去焦点时触发，这个事件不会冒泡
> - focus：获得焦点时触发，不冒泡
> - focusin：在获得焦点时触发，但他冒泡，DOM3 新增
> - focusout：在失去焦点时触发，冒泡

`鼠标事件`：当用户通过鼠标在页面上执行操作时触发

> - click：单击事件，用户单机鼠标按钮（一般是左键）或按下回车键时触发
> - dbclick：双击事件，当双击鼠标时触发（一般是左键）
> - mousedown：当用户在按下任意鼠标按钮时触发
> - mouseup：当用户释放鼠标按钮时触发

```
键盘事件
```

> - keydown：当用户在按下任意键盘按钮时触发
> - keyup：当用户释放键盘按钮时触发
> - Change: 当内容发生变动时

------

## 简述 MySQL 的引擎，myisam 和 innodb 的区别？

> （1）［事务］MyISAM 是非事务安全型的，而 InnoDB 是事务安全型的，
> （2）［锁］MyISAM 锁的粒度是表级，而 InnoDB 支持行级锁定。
> （3）［全文索引］MyISAM 支持全文类型索引，而 InnoDB 不支持全文索引（5.7 之前）。
> （4）［查询效率］MyISAM 相对简单，所以在效率上要优于 InnoDB，小型应用可以考虑使用 MyISAM。
> （5）［外健］MyISAM 不支持外健，InnoDB 支持。
> （6） MyISAM 表是保存成文件的形式，在跨平台的数据转移中使用 MyISAM 存储会省去不少的麻烦。

------

## 简述 session 存储原理和实现 session 共享的方式

```
存储原理
```

> - 当用户第一次访问站点时，PHP 会用 session_start () 函数为用户创建一个 session ID，这就是针对这个用户的唯一标识
> - 每一个访问的用户都会得到一个自己独有的 session ID，这个 session ID 会存放在响应头里的 cookie 中，之后发送给客户端。这样客户端就会拥有一个该站点给他的 session ID。
> - 当用户第二次访问该站点时，浏览器会带着本地存放的 cookie (里面存有上次得到的 session ID) 随着请求一起发送到服务器，服务端接到请求后会检测是否有 session ID，如果有就会找到响应的 session 文件，把其中的信息读取出来；如果没有就跟第一次一样再创建个新的。
> - 通常站点的退出功能，实际上就是调用一下 session_destroy () 函数 (也有可能更复杂些)，把该用户的 session 文件删除，再把用户的 cookie 清除。这样客户端和服务端就算没有联系了。
> - 因为 HTTP 是无状态的，所以一次请求完成后客户端和服务端就不再有任何关系了，谁也不认识谁。但由于一些需要（如保持登录状态等），必须让服务端和客户端保持联系，session ID 就成了这种联系的媒介了。

```
客户端的工作
```

> - 通过上面的分析我们可以知道 session 实际上是依赖与 cookie 的，当用户访问某一站点时，浏览器会根据用户访问的站点自动搜索可用的 cookie，如果有可用的就随着请求一起发送到了服务端。每次接收到服务端的响应时又会更新本地的 cookie 信息。
> - 当然也可以用 GET 方式来传递 session ID，但不推荐用 GET，这样不安全。

```
服务端的工作
```

> 由上面的流程图可以看到，服务端实际上是把产生的一些数据存放在了 session 文件中，该文件的名字就是”sess“加上 session ID，这些文件的存放位置就是 phpinfo () 查到的 session.savepath 值。

```
Session共享:
```

> php 支持把 session 数据存储到 memcache/redis 内存服务器，手动把 seesion 的文件改为 nfs 网络系统文件，从而实现文件的跨机器共享。

------

## 什么是 mvc？

> - Mvc 是程序分为 模型 model - 视图 view - 控制器 controller
> - 模型（m） 是指数据库层操作，比如数据库操作。
> - 视图（v） 是展示给用户的图形化界面，试图还需要护理用户的操作
> - 控制器（c）
> - MVC 全名是 Model View Controller，是模型 (model)－视图 (view)－控制器 (controller) 的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。
> - MVC 被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。

```
优点
```

> 耦合性低、重用性高、生命周期成本低、部署快、可维护性高、有利软件工程化管理
> `缺点`
> 没有明确的定义、不适合小型，中等规模的应用程序、增加系统结构和实现的复杂性、视图与控制器间的过于紧密的连接、视图对模型数据的低效率访问、一般高级的界面工具或构造器不支持模式

------

## Js 中网页前进和后退的代码

> - 前进: history.forward (); 或者 history.go (1);
> - 后退: history.back () 或者 history.go (-1);
> - 刷新:window.location.reload ();

------

## 列举你常见的设计模式，并说明在什么场景下使用？

```
单例模式
```

> - 单例模式是一种常用的软件设计模式。
> - 在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。
> - 应用场景：如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。

```
工厂模式
```

> - 工厂模式主要是为创建对象提供了接口。
> - 应用场景如下：
> - a、 在编码时不能预见需要创建哪种类的实例。
> - b、 系统不应依赖于产品类实例如何被创建、组合和表达的细节。

```
策略模式
```

> - 策略模式：定义了算法族，分别封装起来，让它们之间可以互相替换。此模式让算法的变化独立于使用算法的客户。
> - 应用场景如下。
>   a、 一件事情，有很多方案可以实现。
>   b、我可以在任何时候，决定采用哪一种实现。
>   c.、未来可能增加更多的方案。
>   d、 策略模式让方案的变化不会影响到使用方案的客户。
> - 举例业务场景如下。
>   系统的操作都要有日志记录，通常会把日志记录在数据库里面，方便后续的管理，但是在记录日志到数据库的时候，可能会发生错误，比如暂时连不上数据库了，那就先记录在文件里面。日志写到数据库与文件中是两种算法，但调用方不关心，只负责写就是。

```
观察者模式
```

> - 观察者模式又被称作发布 / 订阅模式，定义了对象间一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。
> - 应用场景如下：
>   a、对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变。
>   b、对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。

```
迭代器模式
```

> - 迭代器模式提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。
> - 应用场景如下：
>   当你需要访问一个聚集对象，而且不管这些对象是什么都需要遍 历的时候，就应该考虑用迭代器模式。其实 stl 容器就是很好的迭代器模式的例子。

```
模板方法模式
```

> - 模板方法模式定义一个操作中的算法的骨架，将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些步骤。
> - 应用场景如下：
>   对于一些功能，在不同的对象身上展示不同的作用，但是功能的框架是一样的。

------

## 请写出 php5 权限控制修饰符？

> - Private 私有的
> - protected 受保护的
> - public 共有的

------

## 如何实例化一个名为 myclass 的对象？

> $myclass=new 对象 ()

------

## 如何我的网站使用的 utf8 编码，为防止乱码出现，需要注意那些问题？

> 1. 数据库中库和表字段中都用 utf8_general_ci 编码
> 2. php 连接 mysql，指定数据库编码为 utf8 mysql_query (“set namesutf8”);
> 3. php 文件指定头部编码为 utf-8 header (“content-type:text/html;charset=utf-8”);
> 4. 网站下所有文件的编码为 utf8
> 5. html 文件指定编码为 utf-8 <content="text/html;charset=utf-8" />

------

## 请解析如下错误提示可能是什么问题？Catchable fatal error:Argument 1 passed to dok () must be an array,integer given ,called in /www/html/test.php on line 2

> 问题是参数 1 传递时不是数组

------

## 请问 PHP 中 echo 和 print print_r var_dump 有什么区别？

> - Echo 不是一个函数，可以一次输出多个值，多个值之间用逗号分隔，echo 只能打印出普通变量的值。
> - print 是一个语法结构 (language constructs), 他并不是一个函数
> - Print_r 作用是输出一个数组结构
> - Var_dump 函数输出数组结构，但并不格式化

------

## 请问 GET 和 POST 方法有什么区别？

> - GET 在浏览器回退时是无害的，而 POST 会再次提交请求。
> - GET 产生的 URL 地址可以被注入，而 POST 不可以。
> - GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。
> - GET 请求只能进行 url 编码，而 POST 支持多种编码方式。
> - GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。
> - GET 请求在 URL 中传送的参数是有长度限制的，而 POST 么有。
> - 对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。
> - GET 参数通过 URL 传递，POST 放在请求体中。

------

## 如何使用 php 实现多继承？

> - PHP 类不支持多继承，也就是子类只能继承一个父类，但是接口可以实现多继承，可以继承一个或者多个接口。当然接口的继承也是和类的继承一样使用 extends 关键字，要多个继承的话只要用逗号把继承的接口隔开即可。
> - 自 PHP 5.4.0 起，PHP 实现了一种代码复用的方法，称为 trait。Trait 是为类似 PHP 的单继承语言而准备的一种代码复用机制。Trait 和 Class 相似，Trait 可以理解为一组能被不同的类都能调用到的方法集合，但 Traits 不是类！不能被实例化.

------

## 如何解决 ajax 请求缓存的问题？

> url 参数添加随机数或时间戳，后缀的方式解决问题，这样就会多了一个一直在变的参数

------

## 写出一下服务默认使用的端口号 FTP ssh https redis smtp Php-fpm mysql mongo

> - FTP 的端口是 21
> - SSH 服务使用 tcp 22 端口
> - HTTPS 服务器，默认的端口号为 443/tcp 443/udp
> - SMTP 默认的端口号为 25/tcp
> - mysql 默认端口是 3306
> - redis 默认端口号 6379
> - Php-fpm 默认端口号 9000
> - Mongo 默认端口号 27017

------

## 如何防止 sql 注入？简要说明常用的方法以及和其优缺点？

```
什么是sql注入
```

> 所谓 SQL 注入，就是通过把 SQL 命令插入到 Web 表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令。具体来说，它是利用现有应用程序，将（恶意的）SQL 命令注入到后台数据库引擎执行的能力，它可以通过在 Web 表单中输入（恶意）SQL 语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行 SQL 语句

```
如何防止
```

> 1: 对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和双 "-" 进行转换等
> 2：检查输入的数据是否具有所期望的数据格式，严格限制变量的类型
> 3 : 不要把机密信息直接存放，加密或者 hash 掉密码和敏感的信息
> 4：使用 pdo 过滤传入的参数
> \5. 应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装
> 6:：永远不要使用动态拼装 sql, 可以使用参数化的 sql 或者直接使用存储过程进行数据查询存取

------

## 简要说明以下 PHP 扩展的用途 APC iconv curl sockets reflection

> - APC PHP 缓存”。它为我们提供了缓存和优化 PHP 的中间代码的框架。 APC 的缓存分两部分：系统缓存和用户数据缓存。
> - iconv 字符集转换 可以转换文件或者数据的字符集编码格式
> - curl curl 是一个非常强大的开源库，支持很多协议，包括 HTTP、FTP 等，我们使用它来发送 HTTP 请求。它给我 们带来的好处是可以通过灵活的选项设置不同的 HTTP 协议参数，并且支：持 HTTPS。CURL 可以根据 URL 前缀是 “HTTP” 还是 “HTTPS” 自动选择是否加密发送内容。
> - Socket: 又称之为 “套接字”，是系统提供的用于网络通信的方法。比如使用 php 搭建 web 服务器，长链接使用
> - reflection：这个功能使得程序员可以通过 PHP 代码，就可以得到某 object 的所有信息，并且可以和它交互

------

## PHP 获取远程的内容有哪些方法？

> \1. 用 file_get_contents 方法 以 get 方式获取远程内容：
> \2. 使用 curl 库，使用 curl 库之前，可能需要查看一下 php.ini 扩展是否已经打开了，curl 扩展可实现不通过浏览器 从本服务器直接请求另一个服务器的作用

------

## Memache 和 memcached 的区别？

> memcached 支持 Binary Protocol，而 memcache 不支持，意味着 memcached 会有更高的性能。不过，还需要注意的是，memcached 目前还不支持长连接。memcached 比 memcache 支持更多的 memcache 协议，大概也就是说 memcached 有更多的方法，比如 getMulti () 和 setMulti () 函数非常有用，但是 memcache 并不支持。

------

## 防止 session_id 泄露的方法？

> 1: 在登录验证成功后，通过重置 session，使之前的匿名 sessionId 失效，这样可以避免使用伪造的 sessionId 进行攻击。request.getSession ().invalidate (); 这样登录前与登录后的 sessionID 就不会相同
> 2 设置 httpOnly 属性
> httponly 是微软对 cookie 做的扩展，该值指定 Cookie 是否可通过客户端脚本访问，解决用户的 cookie 可能被盗用的问题，减少跨站脚本攻击
> 主流的大多数浏览器已经支持此属性。httpOnly 是 cookie 的扩展属性，并不包含在 servlet2.x 的规范里，因此一些 javaee 应用服务器并不支持 httpOnly，针对 tomcat，>6.0.19 或者 > 5.5.28 的版本才支持 httpOnly 属性，具体方法是在 conf/context.xml 添加 httpOnly 属性设置。
>
> 3：另一种设置 httpOnly 的方式是使用 Tomcat 的 servlet 扩展直接写 header
> response.setHeader( "Set-Cookie", "name=value; HttpOnly");

------

## Ning 日志怎么统计每个 ip 的访问量？

```
日志文件所在地方：
```

> /var/log/nginx/access_iqueendress.com.log
> /var/log/nginx/access_m.iqueendress.com.log
> cd /var/log/nginx/

```
1.根据访问IP统计UV
```

> awk '{print $1}' access_iqueendress.com.log|sort | uniq -c |wc -l
> awk '{print $1}' access_m.iqueendress.com.log|sort | uniq -c |wc -l
> awk '{print $1}' access*.log|sort | uniq -c |wc -l

```
4.查询访问最频繁的IP 倒序排序列表
```

> awk '{print $1}' access*.log|sort | uniq -c |sort -n -k 1 -r|more
>
> \1. 根据访问 IP 统计 UV
> awk '{print $1}' access.log|sort | uniq -c |wc -l
> \2. 统计访问 URL 统计 PV
> awk '{print $7}' access.log|wc -l
> \3. 查询访问最频繁的 URL
> awk '{print $7}' access.log|sort | uniq -c |sort -n -k 1 -r|more
> \4. 查询访问最频繁的 IP
> awk '{print $1}' access.log|sort | uniq -c |sort -n -k 1 -r|more
> \5. 根据时间段统计查看日志
> cat access.log| sed -n '/14\/Mar\/2015:21/,/14\/Mar\/2015:22/p'|more

------

## Laravel 框架的中间件如何实现？

> 中间件为过滤进入应用的 HTTP 请求提供了一套便利的机制。例如，Laravel 内置了一个中间件来验证用户是否经过认证（如登录），如果用户没有经过认证，中间件会将用户重定向到登录页面，而如果用户已经经过认证，中间件就会允许请求继续往前进入下一步操作。
> 当然，除了认证之外，中间件还可以被用来处理很多其它任务。比如：CORS 中间件可以用于为离开站点的响应添加合适的头（跨域）；日志中间件可以记录所有进入站点的请求，从而方便我们构建系统日志系统。

------

## Php 框架中单入口功能的实现原理以及必要性？

> 大部分 php 框架都是单一入口模式，竟来的所有 http 请求都会指向一个文件，从这个入口文件进去，进去再去访问别的文件进行相应的操作，而这个原理就是 php 与服务器的配合，讲所有请求的路径转换给 index。Php 做字符串请求的判断即可达到路由解析功能，由于所有的 http 请求都由 index。Php 接受，所以可以集中的安全性检查

------

## 请分别写出避免 sql 注入和 xss 攻击的方法？

```
xss防止
```

> 1: 正则过滤特殊字符，比如 < > = ‘’
> 2 去除 html 标签 strp_tags ()
> 3 利用 php 函数特殊字符转义 htmlentities () addslashes（）

```
sql如何防止
```

> 1 对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和双 "-" 进行转换等
> 2：检查输入的数据是否具有所期望的数据格式，严格限制变量的类型
> 3 : 不要把机密信息直接存放，加密或者 hash 掉密码和敏感的信息
> 4：使用 pdo 过滤传入的参数
> \5. 应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装
> 6:：永远不要使用动态拼装 sql, 可以使用参数化的 sql 或者直接使用存储过程进行数据查询存取

------

## Apache 和 ningx 的区别以及用法？优缺点？

> `Apache`：Web 服务器端软件，由于其跨平台和安全性被广泛使用，是最流行的 web 服务器端软件之一，特点是：简单、速度快、性能稳定，并可做代理服务器来使用。

```
Apache优点：
```

> - Apache 的 rewrite 比 nginx 强大，在 rewrite 频繁的情况下，用 apache。
> - Apache 超稳定。
> - Apache 对 php 支持比较简单，nginx 需要配合其他后端使用。
> - apache 在处理动态请求有优势，nginx 在这方面是鸡肋，一般动态请求要 apache 去做，nginx 适合静态和反向。
> - apache 仍然是目前的主流，拥有丰富的特性，成熟的技术和开发社区。
> - apache 更为成熟，少 bug ，nginx 的 bug 相对较多
> - Nginx：轻量级的 web 服务器 / 反向代理服务器及电子邮件代理服务器，其特点是：占用内存少，并发能力强，国内向百度、京东、淘宝等都在使用。

```
ningx优点：
```

> - 轻量级，采用 C 进行编写，同样的 web 服务，会占用更少的内存及资源。
> - 抗并发，nginx 以 epoll and kqueue 作为开发模型，处理请求是异步非阻塞的，负载能力比 apache 高很多，而 apache 则是阻塞型的。在高并发下 nginx 能保持低资源低消耗高性能 ，而 apache 在 PHP 处理慢或者前端压力很大的情况下，很容易出现进程数飙升，从而拒绝服务的现象。
> - nginx 的设计高度模块化，编写模块相对简单。
> - nginx 作为负载均衡服务器，支持 7 层负载均衡。
> - nginx 处理静态文件好，静态处理性能比 apache 高三倍以上。
> - nginx 配置简洁，正则配置让很多事情变得简单，而且改完配置能使用 -t 测试配置有没有问题，apache 配置复杂 ，重启的时候发现配置出错了，会很崩溃。

------

## 对于框架中路由实现的大致方法？

> 通过伪静态来实现单一入口，将所有请求通过 apache 伪静态解析转给某个指定文件，然后通过 php 的 `$_SERVER[]` 这个全局变量来去的请求的路径字符串，对其进行解析再分配指定的类去处理。

```
基本思路
```

> 浏览器端通过 URL 字符串提供控制器类的名字和方法的名字，PHP 据此找到对应得类和方法。

------

## 几种编程模式，在什么时候使用？

> - 初级模式：初级模式就是前台界面和业务处理代码混合在一起，在哪里显示，就在哪里处理。这种模式是 php 编程最初级的模式，也是最原始的。如果一个程序比较小，不需要太复杂的处理，就可以使用这种模式。
> - 分层模式：分层模式就是把界面和业务分开，放在不同文件中，是一种面向对象编程模式，形成多个层次，责任分工。
> - MVC 模式：一种面向对象编程模式，把软件系统 分为三个基本部分：模型 （Model）、视图（View）和控制器（Controller）。MVC 模式用一种业务逻辑、数据、界面显示分离的方法组织代码，可有效提升代码的重用性。
>   控制器有两个作用：
>   \1. 调取视图进行页面显示
>   \2. 调取模型实现具体逻辑代码的执行程序，最终将结果返回给控制器

------

## Echo count（’www.baidu.com’）输出什么？

> Count () 函数用来计算取值范围内的数字项的个数。
> www.baidu.com 是一个字符串所以输出的是 1

------

## http 协议中的几个状态码以及含义？

> - 100：客户必须继续发送请求
> - 200：请求成功
> - 203：返回信息不确定或者不完整
> - 205：服务器完成了请求，用户代理必须复位当前已经浏览过的文件
> - 301：删除请求数据
> - 302：在其他地址发现了请求数据
> - 400：错误请求
> - 403：请求不允许
> - 404：找不到文件
> - 500：服务器产生内部错误
> - 501：服务器不支持请求的函数
> - 503：服务器所在或暂停维修

------

## 单点登录的实现原理？

```
简介
```

> 单点登录是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统的保护资源，若用户在某个应用系统中进行注销登录，所有的应用系统都不能再直接访问保护资源，
> 像一些知名的大型网站，如：淘宝与天猫、新浪微博与新浪博客等都用到了这个技术。

```
原理
```

> 单点登录 有一个独立的认证中心，只有认证中心才能接受用户的用户名和密码等信息进行认证，其他系统不提供登录入口，只接受认证中心的间接授权。
> 间接授权通过令牌实现，当用户提供的用户名和密码通过认证中心认证后，认证中心会创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌即得到了授权，然后创建局部会话。

------

## 对命名空间的理解？

> - 一般情况向，在一个 php 程序源代码文件或同一个请求中是不允许有两个以上相同名称的类名、常量名或者函数名的，这样的话，程序在运行的时候就会报错。但是，在很多实际情况下，我们是无法避免在同一个文件下有两个以上相同名称的类名、常量名或者函数名的。这种情况下就需要引入命名空间。
> - 我们把这个 PHP 文件想象成是一个文件夹，而里面的两个函数想象成是两个文件，但是在同一个文件夹下是不允许有两个相同名称的文件的，所以我们就必须的将他们分到两个不同名称的文件夹中。命名空间的道理就是这样的。
>
> 命名空间可以解决下面两个问题：
> （1）用户编写的代码与 PHP 内部的类 / 函数 / 常量或第三方类 / 函数 / 常量之间的名字冲突。
> （2）为很长的标识符创建一个别名，提高代码的可读性，减少代码的编写量。

------

## 往一张数据量比较大的表中添加字段，怎么添加？

> [https://blog.csdn.net/jiahao1186/article/d...](https://blog.csdn.net/jiahao1186/article/details/81039613)

------

## Php 魔术方法？

> - __construct 构造函数 初始化赋值 实例化对象的时候自己调用
> - __destruct 析构方法，PHP 将在对象被销毁前（即从内存中清除前）调用这个方法
> - __get 当调用一个未定义的属性时，此方法会被触发，传递的参数是被访问的属性名
> - __set ($property, $value) 给一个未定义的属性赋值时，此方法会被触发，传递的参数是被设置的属性名和值 这里的没有声明包括当使用对象调用时，访问控制为 proteced,private 的属性（即没有权限访问的属性）。
> - __isset ($property) 当在一个未定义的属性上调用 isset () 函数时调用此方法
> - __unset ($property) 当在一个未定义的属性上调用 unset () 函数时调用此方法
> - _call ($method, $arg_array) 当调用一个未定义的方法是调用此方法
> - __autoload 函数，它会在试图使用尚未被定义的类时自动调用。通过调用此函数，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。
> - **clone 复制一个对象时自动调用 clone 方法，如果在对象复制需要执行某些初始化操作，可以在** clone 方法实现。
> - __toString 方法在将一个对象转化成字符串时自动调用，比如使用 echo 打印对象时。
> - __sleep 串行化的时候用
> - __wakeup 反串行化的时候调用 _invoke
> - **invoke 当尝试以调用函数的方式调用一个对象时，**invoke 方法会被自动调用。
> - **callStatic 它的工作方式类似于** call () 魔术方法，__callStatic () 是为了处理静态方法调用

------

## 请看一下 $_SERVER [‘REMOTE_ADDR’] 和 $_SERVER [‘HTTP_X_FORWARED_FOR’] 的作用和区别？

> - php 中 `$_SERVER参`数 HTTP_X_FORWARDED_FOR &REMOTE_ADDR 与获取 IP
> - 在 PHP 中使用 `$_SERVER["REMOTE_ADDR"]` 来取得客户端的 IP 地址，但如果客户端是使用代理服务器来访问，那取到的就是代理服务器的 IP 地址，而不是真正的客户端 IP 地址。
> - 要想透过代理服务器取得客户端的真实 IP 地址，就要使用 `$_SERVER["HTTP_X_FORWARDED_FOR"]` 来读取。

------

## 请列举自己常用的 PHP 函数，并说明其作用？

```
数组函数
```

> - array_change_key_case — 返回字符串键名全为小写或大写的数组
> - array_chunk — 将一个数组分割成多个
> - array_slice — 从数组中取出一段
> - array_keys — 返回数组中部分的或所有的键名
> - array_flip — 交换数组中的键和值
> - array_count_values — 统计数组中所有的值出现的次数

```
字符串函数
```

> - strlen：获取字符串长度，字节长度
> - substr_count 某字符串出现的次数
> - substr：字符串截取，获取字符串
> - str_split 函数把字符串分割到数组中
> - trim：去掉函数两边的字符，默认是空格
> - ucfirst 首字母大写

------

## 如何确保多个进程同时写一个文件成功，请用 PHP 实现？

```php
function write_file($filename, $content)
{
    $lock = $filename . '.lck';
    $write_length = 0;
    while(true) {
        if( file_exists($lock) ) {
            usleep(100);
        } else {
            touch($lock);
            $write_length = file_put_contents($filename, $content, FILE_APPEND);
            break;
        }
    }
    if( file_exists($lock) ) {
        unlink($lock);
    }
    return $write_length;
}
```

## 如何把一个正常页面的状态码输出为 404？

```
404
```

> 关于 400 状态码代表请求时出现的错误 404 状态码代表未找到

```
如何输出
```

> - 我们要把正常页面得状态码输出为 404 非常简单 可以使用 PHP 头部 header 的方法
> - Header (‘http/1.1 404 NOT FOUND’) 页面未找到
> - 禁止用 echo 直接输 0 出一个 404 例如 echo 404; 这种方法禁止

------

## jQuery 中 ajax 方式有同步和异步的方式请问参数名是什么？什么时候用同步方式？什么时候异步方式？

> - jquery 中 ajax 方法有个属性 async 用于控制同步和异步，默认是 true, 即 ajax 请求默认是异步请求，如果是 false，表示同步。
> - async 值为 true （异步）
> - 当 ajax 发送请求后，在等待 server 端返回的这个过程中，前台会继续 执行 ajax 块后面的脚本，直到 server 端返回正确的结果才会去执行 success
> - async 值为 false （同步）
> - 当执行当前 AJAX 的时候会停止执行后面的 JS 代码，直到 AJAX 执行完毕后时，才能继续执行后面的 JS 代码

```
应用场景
```

> - 当 AJAX 处理业务，并且不希望在有返回值后执行其后的代码，这个时候采用异步
> - 当 AJAX 处理业务，并且希望在有返回值后执行其后的代码，这个时候采用同步

------

## Memcache 内存满了怎么办？

> 存到硬盘，操作系统都有虚拟内存，当内存满了，都会存到虚拟内存里而虚拟内存是存放在硬盘上，所以 MEMCACHE 满了会存到硬盘要么就增加内存空间，要么将一些临时用的数据操作完之后，立即销毁，避免占内存。

------

## Php 中魔术常量以及作用？

> - **LINE** 文件中的当前行号。
> - **FILE** 文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名
> - **DIR** 文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录
> - **FUNCTION** 本常量返回该函数被定义时的名字（区分大小写）
> - **TRAIT** 返回 trait 被定义时的名字（区分大小写）Trait 名包括其被声明的作用区域
> - **METHOD** 类的方法名，返回该方法被定义时的名字（区分大小写）
> - **NAMESPACE** 当前命名空间的名称

------

## 什么是魔术常量？

> 讲解 PHP 常量的时候，我们知道 PHP 中的常量大部分都是不变的，但是有 8 个预定义常量会随着他们所在代码位置的变化而变化，这 8 个常量被称为魔术常量，这些特殊的常量是不区分大小写。

------

## Php 的按值传递和引用值传递？ ~

> `按值传递`：原来参数的值在调用其他函数之后还是原来的值，函数内对值的任何改变在函数外部都会被忽略。
> `引用传递`：改变了原来的值，函数内对值的任何改变在函数外部也能反映出这些修改
> `应用场景`：按值传递时，php 必须复制值，而按引用传递则不需要复制值，故引用传递一般用于大字符串或对象。
> `优缺点`: 按值传递时，php 必须复制值。对于大型字符串和对象来说，这样做代价很大。按引用传递则不需要复制值，对于性能提高有好处。

------

## Mysql 中说出二个聚合函数？

> - 聚合函数 count（），求数据表的行数
> - 聚合函数 max（），求某列的最大数值
> - 聚合函数 min（）, 求某列的最小值
> - 聚合函数 sum（）, 对数据表的某列进行求和操作
> - 聚合函数 avg ()，对数据，表的某列进行求平均值操作

------

## 什么是聚合函数？

> 聚合函数 aggregation function 又称为组函数。 认情况下 聚合函数会对当前所在表当做一个组进行统计。

```
聚合函数的特点
```

> \1. 每个组函数接收一个参数（字段名或者表达式） 统计结果中默认忽略字段为 NULL 的记录
> \2. 要想列值为 NULL 的行也参与组函数的计算，必须使用 IFNULL 函数对 NULL 值做转换。
> \3. 不允许出现嵌套 比如 sum (max (xx))

------

## 简述论坛中无限分类的实现原理（常用方法）？

```
举例
```

> 就像 windows 下新建一个文件夹，在新建的文件夹下又可以新建一个文件夹，这样无限循环下去，无限分类也是这样，父类可以分 出它子类，子类又可以分出它的子类，这样一直无限循环下去。

```
实现方法
```

> 是对数据完成多次分类，如同一棵树一样，从根开始，到主干、枝干、叶子…… 完成无限极分类，主要运用了两种方法一是递归方式，二是迭代方式。

------

## 用 PHP 打印出前一天的时间格式是 2006-5-10 22:21:21?

> - echo date ('Y-m-d H:i:s',strtotime ('-1 month',time ()))// 打印出前一个月
> - echo date ('Y-m-d H:i:s', strtotime ('-1day')); // 前一天
> - echo date ('Y-m-d H:i:s', strtotime ('-1week'));// 前一周
> - echo date ('Y-m-d H:i:s');// 现在时间
> - echo date ('Y-m-d H:i:s', strtotime ('next Monday'));// 下一个星期一
> - echo date ('Y-m-d H:i:s', strtotime ('last Monday'));// 上一个星期一

------

## 如果要求每隔 5 分钟执行一次脚 five.php 如何实现？

```
linux的脚本程序
crontab  */5 * * * * /usr/local/php/bin/php  five.php
```

------

## 请用正则表达式写出一个函数验证 ip 地址的格式是否正确？

```php
#[1-255]\.[1-255]\.[1-255]\.[1-255]#
```

------

## 用 PHP 写出显示客户端 IP 和服务器 IP 的代码？

> echo "(1) 浏览当前页面的用户的 IP 地址为：";
>
> ```php
> echo $_SERVER['REMOTE_ADDR'];
> ```
>
> echo "(2) 浏览当前页面的用户的 IP 地址为：";
>
> ```php
> echo getenv('REMOTE_ADDR');
> ```
>
> echo "主机 www.baidu.com 的 IP 地址为：";
>
> ```php
> echo gethostbyname(www.baidu.com);
> ```

------

## 如何增加 PHP 脚本的允许执行时间？

> 1、在 php.ini 里面设置
>
> ```php
> max_execution_time = 120;
> ```
>
> 2、通过 PHP 的 ini_set () 函数设置
>
> ```php
> ini_set("max_execution_time", "120");
> ```
>
> 3、通过 set_time_limit () 函数设置
>
> ```php
> set_time_limit(120);
> ```
>
> 以上几个数字设置为 0 则无限制，脚本会一直执行下去，直到执行结束。
> 所以，需要长时间执行的脚本，一般在 php 代码开头处添加如下代码就可以了
>
> ```php
> set_time_limit(0)
> ```

------

## 常用的 PHP debug 工具以及 debug 思路有哪些？

> 12 个 PHP 调试工具，它们将有助于开发人员轻松找出并调试应用程序及脚本中的错误。下面的 PHP 调试工具支持 Ajax 请求，并包含通用数据采集器和基于堆栈的错误处理器。我希望你能在未来的项目中体会到这个列表的方便和有用之处。

```
Kint
```

> 当调试 PHP 代码时，var_dump ()、print_r () 和 debug_backtrace () 是我们最常用的工具。Kint，一个开源软件，一个不需安装的替代者，它提供了更好的调试体验。它巧妙地检测几乎不可读的数据，并将它们定制成规则的输出显示。变量名、文件、行号及包装的函数它全能提示出来。

```
DebugBar
```

> DebugBar 是一个自由开源软件，它可以被集成到任何 PHP 项目用来收集和定位数据。它没有第三方依赖，支持 Ajax 请求，包含通用数据收集器且集成常见的库。生成的 bar 是 100% JavaScript 实现的并被放置在页面底部（像开发工具一样）。新的收集器和视图可以被轻松的添加，并且可以保存或重新运行以前的请求。

```
Pinba
```

> Pinba 是一个可作为 PHP 统计服务使用的开源 MySQL 存储引擎。它使用收到的数据来分析 PHP 应用性能并快速定位任何问题。

```
PHPMD
```

> PHPMD 是一个易于配置，对 PHP 原始依赖指标友好的前端。它在你的代码中的寻找多种潜在问题，包括可能的 bug、不适合的代码、未使用的参数等。

```
Xde Bug
```

> Xdebug 是一个自由开源的用于调试足浴盆和分析 PHP 脚本细节的 PHP 扩展。由于它是一个扩展，所以使用起来很方便，且在编码端只需要很少的设置。它可以提供错误信息中堆栈跟踪和函数跟踪的所有数据，包括用户定义函数的所有参数、函数名、文件名以及行标志。Xdebug 还可以提供内存分配、分析信息和代码覆盖率分析的数据。

```
Whoops
```

> Whoops 是一个使错误处理和调试更容易的 PHP 库。这个库提供基于堆栈的错误处理，并且有一个好看的界面。它有一个处理异常的简单 API，能够跟踪帧及它们的数据，并可以与任何框架整合（end 和 Silex 已经内置集成）。

```
Krumo
```

> 很多 PHP 开发者使用 print_r () 和 var_dump () 对输出难读或未格式化的结果进行调试。Krumo 是这些足浴盆函数的一个替代者，它可以显示任何 PHP 变量的结构化信息。Krumo 运行后，输出会显示成一个围绕 PHP 变量的可折叠的 DHTML 树结构。同时，它通过自身把调试过程 “关掉” 而不是禁用代码里的所有追溯路径的能力加快了调试过程。

```
Php Debugger
```

> 调试是发现并修复 bug 的过程，PHP Debugger 是帮助你快速的找到错误并将它们从你的 PHP 程序中移除的最好的工具。你可以在 PHPEd 中设置足浴盆远程调试，通过 Wizardand DBG 向导中的 PHP 调试设置开启。

```
Php Debug
```

> PHP_Debug 的基本目的是在调试 PHP 代码时提供援助。

```
Webgrind
```

> Xdebug 是最受欢迎的 PHP 调试扩展之一。它提供了许多有用数据来帮助你在源码中查找 bug。

```
PHP_Dyn
```

> PHP_Dyn 是有一个优秀的开源 PHP 调试工具。你可以跟踪函数执行并得到函数参数和返回值的一个输出。

```
MacGDBp
```

> MacGDBp 是一个 MAC OS 上的 PHP 调试器。它有你所期望的所有特性，是一个包含逐句运行及设置断点等功能的全功能调试器。

```
debug思路
```

> 首先从问题看起，因为问题都是界面显示出来的，所以先找到界面问题所触及到的方法，然后通过页面 debug，看参数传递是否有问题，若无问题，再看到接口然后找到对应问题操作时所对应的方法，整个 debug 跑一遍方法，确定问题所在。

------

## Php 超全局变量有那些？

> 1：`$_SERVER` 超级全局变量包含由 web 服务器创建的信息，它提供了服务器和客户配置及当前请求环境的有关信息
> 2：`$_GET` 超级全局变量包含使用 GET 方法传递的参数的有关信息。
> 3： `$_POST` 超级全局变量包含用 POST 方法传递的参数的有关信息。
> 4: `$_COOKIE` 超级全局变量存储了通过 HTTP cookie 传递到脚本的信息。这些 cookie 一般是由以前执行的 PHP 脚本通过 PHP 函数 setcookie ( ) 设置的。
> 5：`$_FILES` 超级全局变量包含通过 POST 方法向服务器上传的数据的有关信息。这个超级全局变量与其他的变量有所不同，它是一个二维数组，包含 5 个元素。第一个下标标示表单的文件上传元素名；第二个下标是五个预定义下标之一，这些下标描述了上传文件的某个属性
> 6: `$_ENV` 超级全局变量提供 PHP 解析所在服务器环境的有关信息
> 7: `$_REQUEST` 超级全局变量是一个全能选手，它记录了通过各种方法传递给脚本的变量，特别是 GET ，POST 和 COOKIE 。
> 8：`$_SESSION` 超级全局变量包含与所有会话有关的信息。注册会话信息能为你提供便利，这样就能在整个网站中引用这些会话信息，而无需通过 GET 或 POST 显示的传递数据。
> 9：`$GLOBALS` 超级全局变量数组可以认为是超级全局变量的超集，包含全局作用域内的所有变量。

------

## PHP 中几种合并数组的方法？并说出优缺点和注意事项？

```
Array_merge();`
`优点
```

> 可以加快合并的速度，
> `缺点`
> 当两个数组进行合并的时候，同样键名的字段就会被覆盖，如果当两个数组中的数据的值都需要取得准确值的时候不可以使用

```
运算符‘+’号合并数组
```

> 缺点 使用‘+’号合并数组，是前面覆盖后面的，和 array_merge () 相反，如果以索引形式出现的数组的内容，合并后如果键值相同也会覆盖掉！

------

## 关于网站静态文件访问提高性能的方法或方式有哪些？

> 1 代码压缩 利用其他的压缩文件对已经写好的 html 代码进行压缩减少文件体积
> 2 文件合并 合并 js 脚本文件 合并 css 样式文件 合并 css 引用的图
> 3 使用 sprite 雪碧图 将多张图片合成一张上传 减少请求次数。
> 4CDN 加速 CDN 是一个全球（或者只有国内，具体看供应商）分布式网络
> 本质上仍然是一个缓存， CDN 一般缓存的是静态资源，如图片，文件，CSS，Script 脚本，静态网页等，但是这些文件问频率很高，将其缓存在 CDN 可极大改善网页的打开速度
> 5 不要出现 404 错误：HTTP 请求时间消耗是很大的，因此使用 HTTP 请求来获得一个没有用处的响应（例如 404 没有找到页面）是完全没有必要的，它只会降低用户体验而不会有一点好处

------

## 抽象类和接口的区别？

> 0、声名抽象类关键字:abstract 声明接口关键字:interface
> 1、抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。
> 2、抽象类要被子类继承，接口要被类实现。
> 3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现
> 4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。
> 5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。
> 6、抽象方法只能申明，不能实现，接口是设计的结果 ，抽象类是重构的结果
> 7、抽象类里可以没有抽象方法
> 8、如果一个类里有抽象方法，那么这个类只能是抽象类
> 9、抽象方法要被实现，所以不能是静态的，也不能是私有的。
> 10、接口可继承接口，并可多继承接口，但类只能单根继承。

------

> - 抽象类 和 接口 都是用来抽象具体对象的。但是接口的抽象级别最高
> - 抽象类可以有具体的方法 和属性，接口只能有抽象方法和不可变常量
> - 抽象类主要用来抽象类别，接口主要用来抽象功能.
> - 抽象类中，且不包含任何实现，派生类必须覆盖它们。接口中所有方法都必须是未实现的。

------

## empty is_null isset 个字的作用分别是什么？

```
empty()：判断变量是否为空
```

> 如果变量没有定义、定义后没有赋值、赋的为 null、赋的为 0、赋的为 "" 空字符串、赋的为 array () 空数组 该函数都将返回 true

```
is_null()：判断变量是否为null值
```

> 如果变量没有定义、定义后没有赋值、赋的为 null 该函数都将返回 true

```
isset()：判断变量是否被赋值
```

> asdqwe DFGZXCGHFDRREW123456
> 只要变量被赋值了，非 NULL 的值，则返回 true

------

## 对比说明 PHP7 和以前版本的区别，做了哪些优化？

> \1. 类型的声明。
> 可以使用字符串 (string), 整数 (int), 浮点数 (float), 以及布尔值 (bool)，来声明函数的参数类型与函数返回值。
> 标量类型声明 有两种模式：强制 (默认) 和 严格模式。
> declare (strict_types=1), 必须放在文件的第一行执行代码，当前文件有效！
> 2.set_exception_handler () 不再保证收到的一定是 Exception 对象
> 在 PHP 7 中，很多致命错误以及可恢复的致命错误，都被转换为异常来处理了。 这些异常继承自 Error 类，此类实现了 Throwable 接口 （所有异常都实现了这个基础接口）。
> PHP7 进一步方便开发者处理，让开发者对程序的掌控能力更强。因为在默认情况下，Error 会直接导致程序中断，而 PHP7 则提供捕获并且处理的能力，让程序继续执行下去，为程序员提供更灵活的选择。
> \3. 新增操作符 “<=>”
> \4. 新增操作符 “??”
> 如果变量存在且值不为 NULL， 它就会返回自身的值，否则返回它的第二个操作数。
> 操作符 “??” 在 php7 版本就相当于三目运算符的升级版。
> 5.define () 定义常量数组
> 6.AST: Abstract Syntax Tree, 抽象语法树
> AST 在 PHP 编译过程作为一个中间件的角色，替换原来直接从解释器吐出 opcode 的方式，让解释器 (parser) 和编译器 (compliler) 解耦，可以减少一些 Hack 代码，同时，让实现更容易理解和可维护.
> PHP5 : PHP 代码 -> Parser 语法解析 -> OPCODE -> 执行
> PHP7 : PHP 代码 -> Parser 语法解析 -> AST -> OPCODE -> 执行
> \7. 匿名函数
> 8.Unicode 字符格式支持 (echo “\u {9999}”)
> 9.Unserialize 提供过滤特性
> 防止非法数据进行代码注入，提供了更安全的反序列化数据。
> \10. 命名空间引用优化

------

## 列举出 HTTP 中常用的几个 Header 属性？

> - Accept 可接受的类型
> - Accept-Charset 可接受的字符集
> - Accept-Language 可接受的响应语言
> - Accept-Encoding 可接受的编码
> - Content-Type, 响应的数据类型：text/html;charset=gbk
> - Content-Length， 响应的数据体大小
> - Content-Encoding, 如果为文本、HTML 信息，则使用的编码方式
> - Date, 当前服务器日期
> - Server, 服务器名

------

Cookie HTTP 请求发送时，会把保存在该请求域名下的所有 cookie 值一起发送给 web 服务器。

## 手机访问 www.baidu.com 会自动跳转到 M.bdaidu.com ?

用重定向的方法强制要求访问的地址有三种方法
`第一种`

```php
$url=m.baidu.com
If(!isset($url)){
Header(‘location:$url’)
}
<?php $url=m.baidu.com
If(!isset($url)){
Exit();}
?>
第一种
<meta http-equiv=’refresh’;  content=’跳转的时间’;url=’<?php echo $url ?>’ >
```

------

## 怎么保证接口安全？做了那些操作？

```
选择拦截过滤器。
```

- > 在请求的时候对请求方法进行一次拦截处理。比如非正常访问的方法已经注入插入可执行语句参数验证等在拦截中进行一次安全校验保证

- > 请求不是非法请求。

`数据加密`我们知道目前大部分 APP 接口都是通过 Http 协议进行调用的容易被抓包拦截。

> - 我们可以对客户端和服务端都对数据传输的时候进行一个加密处理。常用的 MD5 hash 等。
> - Curl 和 file_get_contronts（）区别？
> - Curl 不会缓存 DNS file_get_contronts（可以缓存 DNS，这样多次访问同一个网站的时候，后者的速度会更快
> - Curl 请求 http 时不会 keepalive , file_get_contronts（会，这样多次请求同一个链接时后者的速度会更快
> - Curl 会受 php.ini 文件中配置的影响，关闭之后无法使用，file_get_contronts 不会
> - Curl 只有 get 请求，file_get_contronts 以模拟 post，ftp，tcp 等请求
> - Curl 得到的结果存储在一个字符串中，后者会存储到数组中，这样更方便分析使用

------

## 简述原生 ajax 实现的步骤？

> 1. 创建一个 3 实例化对象 XMLHttpRequest
> 2. 监听事件：使用 onreadystatechange 来监听，在里面有一个 if 判断，当 readystate ==4 时，表示解析完毕，并且当 state ==200 时，表示请求成功。另外从数据库传递过来的是以 responseText 来接收的，但它本身是一种 json 形式，我们要把它转换成 json 对象格式
> 3. 建立连接，使用 open 形式，open 里面有 3 个参数，第一个参数就是请求方式 get 或者 post，第二个参数就是 url 地址，第三个参数就是同步异步，用 true 或者 false 来表示 ，但一般默认情况下是 true 异步的
> 4. 发送请求，使用 send

------

## Mysql 中索引失效的原因？

> \1. 如果条件中有 or，即使其中有条件带索引也不会使用 (这也是为什么尽量少用 or 的原因)
> 要想使用 or，又想让索引生效，只能将 or 条件中的每个列都加上索引
> \2. 对于多列索引，不是使用的第一部分，则不会使用索引
> 3.like 查询以 % 开头
> \4. 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不使用索引
> \5. 如果 mysql 估计使用全表扫描要比使用索引快，则不使用索引

------

## Vi 编辑环境下？使用什么键进行模式转换？

> 掌握 vi 一般模式: vi 编辑器是所有 unix 和 linux 系统下标准的编辑器，他就相当于 windows 系统中的记事本一样，他的强大不逊色于任何最新的文本编辑器。他是我们使用 linux 系统不可缺少的工具。由于对 unix 及 linux 系统的任何版本，vi 编辑器都是完全相同的所有的 unix like 系统都会内建 vi 文本编辑器，其他的文本编辑器则不一定会存在，一些软件的编辑器接口都会主动调用 vi.

**vi 有三种模式**

> - 命令行模式 (一般模式), 文本输入模式
> - vi 打开一个文件就直接进入了一般模式 (这是默认模式), 这个模式中你可以使用上下左右键来移动光标，可以使用删除字符或删除整行来处理文件内容，也可以使用复制，粘贴来出来你的文件数据；
> - 掌握 vi 编辑模式:
> - 在一般模式中可以进行删除，复制，粘贴等操作，但是却无法编辑文件内容，只有当你按下 [A,a,i,I,O,o,R,r] 任何一个
> - 字母之后才会进入编辑模式；这时候屏幕下方会出现 [insert] 字样，此时才能进进行编辑；要回到一般模式，必须要按下 [ESC] 键
> - 退出编辑模式；
> - 掌握 vi 命令行模式:
> - 输入 [: 或 / 或？] 三个中的任何一个，就可以将光标移动到最底下的行。在这个模式中，可以提供查找，读取，存盘，替换字符，离开 vi, 显示行号等动作.

------

------

## Linux 下如何清空一个文件的命令，监视一个日志文件 a.log 的最新内容 ？

> - `echo "" > a.log` 或 `> a.log`
> - `tail -n 50 -f a.log` 显示文件 a.log 的后 50 行内容并在文件内容增加后，自动显示新增的文件内容。
> - `tail: -n` 是显示行号；相当于 nl 命令；例子如下：
> - `tail -100f test.log` 实时监控 100 行日志
> - `tail -n 10 test.log` 查询日志尾部最后 10 行的日志；
> - `-n +10 test.log` 查询 10 行之后的所有日志；
> - `head:` 跟 tail 是相反的，tail 是看后多少行日志；例子如下：
> - `head -n 10 test.log` 查询日志文件中的头 10 行日志；
> - `head -n -10 test.log` 查询日志文件除了最后 10 行的其他所有日志；
> - `cat： cat -n test.log |grep "debug"` 查询关键字的日志

------

## 10g 的访问日志文件中？查看访问日志中访问次数前十的 IP？

\```
cat access_log | awk ‘{print $1}’ | uniq -c|sort -rn|head -10
\```

> // 这个别的方法也能统计，但有些命令是必要的 awk , sort,uniq , 主要看是否这些命令都 使用了。

------

## 查看当前服务器的 http 链接有哪些？

\```
netstat -n|grep 80
\```

------

## Php 在 linux 如何安装拓展？写出安装步骤及命令？

> 下载你要安装的软件包，解压得到目录（如：`phpredis`）
>
> 1. 进入软件包目录（`cd phpredis`）
> 2. 执行 phpsize 命令（`/usr/local/php/bin/phpize`）
>    　　成功后，当前目录将得到 `configure` 文件。
> 3. 进行配置（`./configure --with-php-config=/usr/local/php/bin/php-config　`#指定安装在哪个 PHP）注：如果系统缺少 phpize 命令，且你使用的是预编译的 RPM 包，那么一定要安装适当的 PHP 开发版本，因为它们一般都包含 phpize 命令连同合适的头文件来编译 PHP 及其扩展。
> 4. 编译安装
>    \```
>    　make
>    　make install
>    \```
> 5. 安装成功出现如下提示：
>    　　扩展存放位置：
> 6. 修改 PHP 配置文件（`vim /usr/local/php/etc/php.ini`）
>    \```
>    extension = "/usr/local/php/lib/php/extensions/no-debug-non-zts-20131226/redis.so";
>    或 extension = "redis.so";（注意前面不要加分号，如果已有 extension_dir, 则不需要再写）
>    \```　　　
> 7. 重启服务器
>    \```　pkill -9 nginx ； /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf ```
>    　　用 phpinfo () 在浏览器中查看 PHP 配置清单，ok, 到此安装已完成。

\-----------------------------------------------------------------------------------------------------　　

## 　　一些服务开启的命令:　

　　pkill php-fpm; /usr/local/php/sbin/php-fpm

　　`linux:`

> - 　　/etc/init.d/nginx start|stop|restart 　　# 启动 | 停止 | 重启 nginx
> - 　　/etc/init.d/php-fpm start|stop|restart #启动 | 停止 | 重启 php-fpm
> - 　　/etc/init.d/mysql start|stop|restart 　 #启动 | 停止 | 重启 msyq

　　`freebsd：`

> - 　　/usr/local/etc/rc.d/nginx start|stop|restart 　　　　# 启动 | 停止 | 重启 nginx
> - 　　/usr/local/etc/rc.d/mysql-server start|stop|restart #启动 | 停止 | 重启 mysql
> - 　　/usr/local/etc/rc.d/php-fpm start|stop|restart 　　 #启动 | 停止 | 重启 php-fpm
> - 　　/usr/local/sbin/nginx #启动 nginx
> - 　　/usr/local/sbin/nginx -s stop #停止 nginx
> - 　　/usr/local/sbin/nginx -s reload #重启 nginx

------

## Ningx 和 php 如何通信？在 ningx 文件中如何配置？

> - 　Nginx 本身不会对 PHP 进行解析，终端对 PHP 页面的请求将会被 Nginx 交给 FastCGI 进程监听的 IP 地址及端口，由 php-fpm 作为动态解析服务器处理，最后将处理结果再返回给 nginx。其实，Nginx 就是一个反向代理服务器。Nginx 通过反向代理功能将动态请求转向后端 php-fpm，从而实现对 PHP 的解析支持，这就是 Nginx 实现 PHP 动态解析的原理。
> - 　　Nginx 不支持对外部程序的直接调用或者解析，所有的外部程序（包括 PHP）必须通过 FastCGI 接口来调用。FastCGI 接口在 Linux 下是 socket（这个 socket 可以是文件 socket，也可以是 ip socket）。为了调用 CGI 程序，还需要一个 FastCGI 的 wrapper（wrapper 可以理解为用于启动另一个程序的程序），这个 wrapper 绑定在某个固定 socket 上，如端口或者文件 socket。当 Nginx 将 CGI 请求发送给这个 socket 的时候，通过 FastCGI 接口，wrapper 接收到请求，然后派生出一个新的线程，这个线程调用解释器或者外部程序处理脚本并读取返回数据；接着，wrapper 再将返回的数据通过 FastCGI 接口，沿着固定的 socket 传递给 Nginx；最后，Nginx 将返回的数据发送给客户端。

```
Nginx 简单配置
location ~ \.php$ {
    root /home/admin/web/nginx/html/;
    fastcgi_pass 127.0.0.1:9000;
    fastcgi_index index.php;
    fastcgi_param SCRIPT_FILENAME /home/admin/web/nginx/html/$fastcgi_script_name;
    include fastcgi_params;
}

location ~ \.php$ {
    root /webpath;
    fastcgi_pass 127.0.0.1:9000;
    ...
    ...        
}
```

> 　　这个 location 指令把以 php 为文件后缀的请求，交给 127.0.0.1:9000 处理。我想你看到这个应该猜到了，这是一个 C/S 架构东西。 而这里的 IP 地址和端口（127.0.0.1:9000）就是 fastcgi 进程监听的 IP 地址和端口。fastcgi 是一个可伸缩地、高速地在 http server 和动态脚本语言间通信的接口。多数流行的 http server 都支持 fastcgi，包括 apache、nginx 和 lighttpd 等。同时，fastcgi 也被许多脚本语言支持，其中就有 php。

```
那这个fastcgi的配置IP和端口从何而来呢？在php-fpm.conf中可以看到如下：
```

> - listen = 127.0.0.1:9000 #这个表示 php 的 fastcgi 进程监听的 ip 地址以及端口
> - pm.start_servers = 2
> - 　　php-fpm 作为 fastcgi 的进程管理器，可以有效控制内存和进程，并且平滑重载 php 配置。php5.3 以后，php-fpm 被集成到 php 的 core 中，默认安装，无须配置。
> - 　　fastcgi 进程管理器 php-fpm 自身初始化，启动主进程 php-fpm 和启动 start_servers 个 fastcgi 子进程。主进程 php-fpm 主要是管理 fastcgi 子进程，监听 9000 端口，fastcgi 子进程等待请求。当客户端请求到达 nginx 时，nginx 通过 location 指令，将所有以 php 为后缀的文件都交给 127.0.0.1:9000 来处理。php-fpm 选择并连接到一个 fastcgi 子进程，并将环境变量和标准输入发送到 fastcgi 子进程。fastcgi 子进程完成处理后将标准输出和错误信息返回。当 fastcgi 子进程关闭连接时，请求便告处理完成，等待下次处理。

------

## 写出过滤 html 标签的函数或方法？

> - 过滤 html 标签的函数代码本文章提供四款利用 php 过滤 html 标签的函数代码
> - 方法一最简单的利用了 php 自带函数 strip_tags 来过滤所有的 html 标签，
> - 方法二利用了正则表达式来过滤 html 标签，
> - 方法三是清除 HTML 标签的用户自定义函数，根据 ascii 编码值来判断是否为字母再过滤

------

## 简述 orm 是什么？

> ORM，即 Object-Relational Mapping（对象关系映射），它的作用是在关系型数据库和业务实体对象之间作一个映射，这样，我们在具体的操作业务对象的时候，就不需要再去和复杂的 SQL 语句打交道，只需简单的操作对象的属性和方法。

```
优点？
```

> - 第一：隐藏了数据访问细节，“封闭” 的通用数据库交互，ORM 的核心。他使得我们的通用数据库交互变得简单易行，并且完全不用考虑该死的 SQL 语句。快速开发，由此而来。
> - 第二：ORM 使我们构造固化数据结构变得简单易行。在 ORM 年表的史前时代，我们需要将我们的对象模型转化为一条一条的 SQL 语句，通过直连或是 DB helper 在关系数据库构造我们的数据库体系。而现在，基本上所有的 ORM 框架都提供了通过对象模型构造关系数据库结构的功能。这，相当不错。

```
缺点？
```

> - 第一：无可避免的，自动化意味着映射和关联管理，代价是牺牲性能（早期，这是所有不喜欢 ORM 人的共同点）。现在的各种 ORM 框架都在尝试使用各种方法来减轻这块（LazyLoad，Cache），效果还是很显著的。
> - 第二：面向对象的查询语言 (X-QL) 作为一种数据库与对象之间的过渡，虽然隐藏了数据层面的业务抽象，但并不能完全的屏蔽掉数据库层的设计，并且无疑将增加学习成本.
> - 第三：对于复杂查询，ORM 仍然力不从心。虽然可以实现，但是不值的。视图可以解决大部分 calculated column，case ，group，having,order by, exists，但是查询条件 (a and b and not c and (d or d))。

------

## 简述 trait 的作用？

> - 从 PHP 的 5.4.0 版本开始，PHP 提供了一种全新的代码复用的概念，那就是 Trait。Trait 其字面意思是” 特性”、” 特点”, 我们可以理解为，使用 Trait 关键字，可以为 PHP 中的类添加新的特性。
> - 熟悉面向对象的都知道，软件开发中常用的代码复用有继承和多态两种方式。在 PHP 中，只能实现单继承。而 Trait 则避免了这点。继承的方式虽然也能解决问题，但其思路违背了面向对象的原则，显得很粗暴；多态方式也可行，但不符合软件开发中的 DRY 原则，增加了维护成本。而 Trait 方式则避免了上述的不足之处，相对优雅的实现了代码的复用。

------

## linux 下解压 abc.tar.gz 的命令是什么？常用的文本编辑器是什么？

> 命令格式：`tar -zxvf abc.tar.gz`。解压缩后的文件只能放在当前的目录。

```
解压好处
```

> 在 linux 中使用压缩文件有两个明显好处：一是可以减少存储空间，二是通过网络传输文件时，可以减少传输时间，另外，在向线上传送项目的时候，就可以使用压缩工具来压缩代码，保持代码的完整性。

------

## 常见的文本编辑器？

```
常见的文本编辑器有vi 和vim 以及nano 而我最常用的是vim因为vim是vi 的升级版
```

> - 1.vim 可以多级撤销 (u 键，在 vim 里面可以无限级撤销，vi 只能撤销一次);
> - \2. 易用性 (vi 只能运行于 [unix] 中，vim 可以运行在 [linux,unix,mac,windows] 等多操作平台);
> - \3. 语法加亮 (可以用不同的颜色来加亮代码);
> - \4. 可视化操作 (vim 不仅可以在终端运行，还可以运行于 xwindow,mac os,windows);
> - \5. 最主要的一点就是 vim 对 vi 完全兼容 (某些情况下，可以把 vim 当成 vi 来使用）

```
vi有三种模式：
```

> - 一般模式：以 vi 打开或新建一个文件就可以直接进入一般模式，在此模式中，你可以使用上下左右来进行光标的移动，可以删除字符或整行，可以复制粘贴文件数据。
> - 编辑模式：顾名思义，就是可以编辑文本的模式，在一般模式下，按下 “i，I,o,O,a,A,r,R" 这些字母可进入编辑模式，进入编辑模式后在左下方会有 INSERT 或 REPLACE 的字样。
> - 在编辑模式下按下 ESC 键会退出到一般模式下。
> - 命令行模式：在一般模式下，输入” :, / , ? " 这三个字符中的任意一个会将光标移动到最下面的一行，在这个模式中可以进行数据查找、替换、保存、离开 vi 等操作。

```
Vim有四种模式：
```

> - 正常模式:
> - 启动 vim 默认处于正常模式；
> - 插入模式:
> - 在正常模式下按下 A,O,I,a,o,i 等键，会进入插入模式；
> - 命令模式:
> - 在正常模式中下按 ![:disappointed:](https://cdn.learnku.com/assets/images/twemoji/disappointed.png)英文冒号) 进入命令模式，可以执行一些输入，并执行一些 vim 指令或插件提供的指令
> - 可视模式:
> - v 进入面向字符的可视模式 V 进入面向行的可视模式，Ctrl + v 进入面向列块的可视模式，gv 重选上次的高亮选区
> - 相比于 vi 我更喜欢 vim.
> - 当然了，在 Linux 还有另一个常用文本编辑器 nano，它是可以直接在命令行中敲入 nano filename 即可打开文件或新建文件。
> - nano 下可以使用的一些快捷键，其对应的含义翻译如下：
> - ctrl+G： 取得在线帮助
> - ctrl+O： 保存文件，如果你有权限就可保存修改的文件
> - ctrl+R： 从其他文件读入数据，可将某个文件的内容贴在本文件中
> - ctrl+Y： 显示前一页
> - ctrl+K： 剪切当前行的内容
> - ctrl+C： 显示光标所在的位置

------

## 请列举几个你常用的 linux 命令以及说明？

我最常用的 linux 命令一般分为系统命令，文件以及目录操作的一些命令

```
系统命令有：
```

> - date 显示系统日期
> - cat /cpuinfo 显示 CPU 信息的信息
> - uname - r 显示正在使用的内核版本

```
还有文件的一些操作：
```

> - mkdir dir1 创建一个叫做 ' dir1 ' 的目录 '
> - rm - f file1 删除一个叫做 'file1' 的文件 '
> - rmdir dir1 删除一个叫做 ' dir1 ' 的目录 '
> - rm - rf dir1 删除一个叫做 'dir1' 的目录并同时删除其内容
> - mv dir1 new_dir 重命名 / 移动一个目录
> - cp file1 file2 复制一个文件

```
以及给文件设置权限的命令：
```

> - Chmod
> - u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体 (group) 者，o 表示其他以外的人，a 表示这三者皆是。
> - - 表示增加权限、- 表示取消权限、= 表示唯一设定权限。
> - r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。
> - Chmod -R : 对目前目录下的所有文件与子目录进行相同的权限变更

```
对用户和用户组的一些命令有：
```

> - groupadd group_name 创建一个新用户组
> - groupdel group_name 删除一个用户组
> - useradd user1 创建一个新用户
> - userdel - r user1 删除一个用户

------

## 写一个 linux 命令，以实现查看进程中是否有 php 进程？

> - ps -ef 可以查看当前所有的的进程
> - ps -ef |grep ‘php’less 可以逐条查看匹配 php 的所有的进程

```
找到相关的pid
```

> - --1. 用 top 找出 CPU 占用率高的 PHP 进程
> - --2. 用 strace -p <进程编号> 可以查看进程的具体工作内容
> - ps –ef 可以查看当前的所有进程
> - ps -ef|grep 可以逐条查看匹配 PHP 的所有的进程

------

## 如何查看服务器当前 cpu 使用情况？

> - 查看 cpu 使用情况 top 命令是 Linux 下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于 Windows 的任务管理
>
> - 查看内存使用情况 使用命令：free -m
>
> - 查看显卡使用情况 使用命令：nvidia-smi
>
> - 使用 linux 命令实现按照日期排序 显示 /home/abc 下面所有.txt 文件？
>
> - 按照日期的顺序，显示 /home/abc/ 下面的的所有.txt 文件
>
> - 如果我们要查询某个目录下的所有的 .txt 文件，并且还要按照日期的顺序，我们可以用 ls 这个命令来查看指定的文件，其中 ls 有以下几个参数：
>
> - -a 显示所有文件及目录 (ls 内定将文件名或目录名称开头为 "." 的视为隐藏档，不会列出)
>
> - -l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出
>
> - -R 若目录下有文件，则以下之文件亦皆依序列出
>
> - 比如我们这个题要求的查看 /home/abc/ 下的所有 txt 文件，这时我们就可以使用 ls -al /home/abc/ *.txt 这个命令来显示该目录下的所有 txt 文件，如果要是按照时间进行排序的话，可以使用 sort 命令，在使用 sort 命令的时候可以在后面加上按照时间排序的参数 --time, 另外，sort 还有一下其他的参数比如：
>
> - none（-U）, 无
>
> - extension（-X）, 扩展名
>
> - size （-S）, 大小
>
> - time（-t）, 修改时间
>
> - version （-v），版本
>
> - 如果不接参数的话，sort 会默认采用升序的方式进行排序，总结一下，这个命令就是
>
>   ```php
>   Ls -al /home/abc/ * .txt --sort=time
>   ```

------

## 请说出 top ps mv find df cat chmod chgrp grep wc 的命令用法？

> - top：命令是 Linux 下常用的 性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于 Windows
> - 的任务管理器。
> - ps：查看进程
> - mv：移动或者更改文件
> - find：在子目录中搜索匹配的文件
> - df：linux 中 df 命令参数功能：检查文件系统的磁盘空间占用情况。
> - cat：把一个或多个文件内容显示到标准输出
> - chmod：改变文件属性
> - chgrp：改变用户分组
> - grep：在 77 文件内进行搜索
> - wc：命令的功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出。

------

## Php 的语言结构和函数有什么区别？

```
什么是语言结构和函数
```

> - 语言结构：就是 PHP 语言的关键词，语言语法的一部分；它不可以被用户定义或者添加到语言扩展或者库中；它可以有也可以没有变量和返回值。
> - 函数：由代码块组成的，可以复用。从源码的角度来说，也就是基于 Zend 引擎的基础来实现的，ext 拓展库中的函数都是这样实现的。

```
语言结构和函数的不同
```

> - （1）语言结构比对应功能的函数快
> - （2）语言结构在错误处理上比较鲁棒，由于是语言关键词，所以不具备再处理的环节
> - （3）语言结构不能在配置项 (php.ini) 中禁用，函数则可以。
> - （4）语言结构不能被用做回调函数

```
语言结构为什么比函数快
```

> - 原因是在 PHP 中，函数都要先被 PHP 解析器（Zend 引擎）分解成语言结构，所以有此可见，函数比语言结构多了一层解析器解析。这样就能比较好的理解，什么语言结构比函数快了。
> - 语言结构列表
> - echo() print() die() isset() unset() include() require() array() list() empty()

------

## 数据库中的事务是什么？

> 是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的 ACID（原子性、一致性、隔离性和持久性）属性。事务是数据库运行中的逻辑工作单位，由 DBMS 中的事务管理子系统负责事务的处理。

只有这样才能成为一个事务：

```
原子性
```

> 事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。

```
一致性
```

> - 事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。
> - 事务结束时，所有的内部数据结构（如 B 树索引或双向链表）都必须是正确的。

```
隔离性
```

> - 由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，
> - 要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。这称为可串行性，因为它能够重新装载起始数据，
> - 并且重播一系列事务，以使数据结束时的状态与原始事务执行的状态相同。

```
持久性
```

> 事务完成之后，它对于系统的影响是永久性的。该修改即使出现系统故障也将一直保持。

------

## 优化 mysqlSQL 语句的方式或方法是什么？

> - （1）开启慢查询（查看需要优化的语句）
> - （2）show processlist
> - (3) 使用 explain 分析 SQL 语句是否是否需要索引以及索引是否尽到最大的优化效果（得到最优化的 SQL 语句）
> - （4）使用性能优化器 profile（分析 SQL 语句的执行时间 以及缓存的占用量）
> - （5）使用联合 (UNION) 来代替手动创建的临时表
> - 它可以把需要使用临时表的两条或更多的 select 查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。使用 union 来创建查询的时候，我们只需要用 UNION 作为关键字把多个 select 语句连接起来就可以了
> - （6）选取最适用的字段属性
> - 可能的情况下，应该尽量把字段设置为 NOTNULL，这样在将来执行查询的时候，数据库不用去比较 NULL 值
> - （7）使用连接（JOIN）来代替子查询 (Sub-Queries)
> - 虽然使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的 SQL 操作，同时也可以避免事务或者表锁死，并且写起来也很容易，但是有些情况下子查询可以被更有效率的连接（JOIN）.. 替代，比如在查询用户订单的时候，使用连接的效果就比子查询要好得多。
> - （8）使用事务
> - 当一个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来，会造成数据的不完整，甚至会破坏数据库中的数据。要避免这种情况，就应该使用事务，这时候事物的作用就是要么语句块中每条语句都操作成功，要么都失败。换句话说，就是可以保持数据库中数据的一致性和完整性
> - （9）使用索引
> - 索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快得多的速度检索特定的行，尤其是在查询语句当中包含有 MAX (),MIN () 和 ORDERBY 这些命令的时候，性能提高更为明显
> - （10）优化的查询语句
> - 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。
> - 应尽量避免在 where 子句中使用！= 或 <> 操作符，否则将引擎放弃使用索引而进行全表扫描。
> - 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描
> - 应尽量避免在 where 子句中使用 or 来连接条件 in 和 not in 也要慎用，否则会导致全表扫描
> - 应尽量避免在 where 子句中对字段进行表达式操作
> - 尽量避免在 where 子句中对字段进行函数操作
> - 当我们优化查询语句的时候注意以下几点：
> - 首先，最好是在相同类型的字段间进行比较的操作
> - 其次，在建有索引的字段上尽量不要使用函数进行操作
> - 最后，应该注意避免在查询中让 MySQL 进行自动类型转换，因为转换过程也会使索引变得不起作用

------

## Mysql 中 varchar 和 char 的区别是什么？那种效率高，为啥么？

> - 在 mySQL 中 char 和 varchar 都是存储字符串的，区别在于 char 有固定的长度，而 varchar 属于可变长的字符类型。
> - char (M) 类型的数据列里，每个值都占用 M 个字节，如果某个长度小于 M，MySQL 就会在它的右边用空格字符补足．（在检索操作中那些填补出来的空格字符将被去掉）在 varchar (M) 类型的数据列里，每个值只占用刚好够用的字节再加上一个用来记录其长度的字节（即总长度为 L+1 字节）。
> - char 固定长度，所以在处理速度上要比 varchar 快速很多，但是对费存储空间，所以对存储不大，但在速度上有要求的可以使用 char 类型。
> - 总的说来：char 定长，存储效率不如 varchar，对于短数据的查询优于 varchar

------

## 用 shell 命令找出‘当前目录下文件内容最近两天内被修改过且后缀为.txt’的文件？

> - find -name ‘*.txt’ –mtime 1 –type –f ls
> - find . -name ‘*.txt’ -mtime 1 -type f -ls
> - find 命令：在指定的目录搜索文件

```
常用的option：
```

> - -name：指定文件名，或者使用 “*.py” 来指定文件的后缀名，
> - -type：指定要搜索的文件类型，常见的文件类型有：b 表示块设备，c 字符设备，d 文件目录，f 普通文件等
> - -readable：文件可读
> - -writable：文件可写
> - -executable：文件可执行
> - -ls：在搜索结果中显示文件的详细信息
> - -empty: 普通文件或者文件夹是空的

```
查找最近修改的文件：
```

> - -ctime：指定时间内文件的权限被修改过，change
> - -atime：指定时间内文件被访问过（读取），access
> - -mtime：指定时间 (以天为单位) 内文件被修改过，modify 0 (最近 24 小时内) 1 (最近 24-48 小时内)
> - -mmin：指定时间 (以分钟为单位) 内文件被修改过，modify -30 (最近三十分钟)

------

## 请说出 mysql 常用的存储引擎？Memory 存储引擎的特点？

```
mysql的存储引擎是什么呢？
```

> 简单来说，存储引擎就是指表的类型以及表在计算机上的存储方式，不同的存储引擎决定了 MySQL 数据库中的表可以用不同的方式来存储。我们可以根据数据的特点来选择不同的存储引擎

```
存储引擎有
```

> - InnoDB 存储引擎
> - MyIsam 存储引擎
> - Memory 存储引擎（也叫 HEAP）堆内存
> - Mrg_Myisam 存储引擎（分表的一种方式–水平分表）
> - Blackhole（黑洞引擎）

```
而我做常用的存储引擎有InnoDB、MyISAM、MEMORY这三种。
```

> - InnoDB 给 MySQL 的表提供了事务处理、回滚、崩溃修复能力和多版本并发控制的事务安全。它是 MySQL 上第一个提供外键约束的表引擎。而且 InnoDB 对事务处理的能力，也是其他存储引擎不能比拟的。靠后版本的 MySQL 的默认存储引擎就是 InnoDB。
> - InnoDB 的优点：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择 InnoDB 有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择 InnoDB，因为支持事务的提交和回滚。
> - MyISAM 是 MySQL 中常见的存储引擎，曾经是 MySQL 的默认存储引擎。基于 MyISAM 存储引擎的表支持 3 种不同的存储格式。包括静态型、动态型和压缩型。其中，静态型是 MyISAM 的默认存储格式，它的字段是固定长度的；动态型包含变长字段，记录的长度不是固定的；压缩型需要用到 myisampack 工具，占用的磁盘空间较小。MyISAM 的优势在于占用空间小，处理速度快。
> - MyISAM 的优点：插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择 MyISAM 能实现处理高效率。如果应用的完整性、并发性要求比较低，也可以使用。
> - Memory 是 MySQL 中一类特殊的存储引擎最主要的特点有两个，一个是他使用存储在内存中的内容来创建表，而且数据全部存放在内存中，而且每个基于 MEMORY 存储引擎创建的表实际上都对应一个磁盘文件，该文件的文件名与表名相同，类型为 frm 类型。
> - 其中数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。另一个特点是 MEMORY 默认使用哈希索引，使用哈希索引时索引速度比使用 B 型树索引快。但是，使用 memory 有一个需要注意的地方，因为 memory 是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于 MEMORY 创建的表的生命周期都很短，一般都是一次性的。

------

## 什么是队列？排它锁，myisam 死锁如何解决？

> - 队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，在前端进行删除操作在默认情况下 MYisam 是表级锁，所以同时操作单张表的多个动作只能以队列的方式进行；而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头
> - 排它锁又名写锁，在 SQL 执行过程中为排除其它请求而写锁，在执行完毕后会自动释放；

```
共享锁与排它锁区别
```

> \1. 共享锁只用于表级，排他锁用于行级。?
> \2. 加了共享锁的对象，可以继续加共享锁，不能再加排他锁。加了排他锁后，不能再加任何锁。?
> \3. 比如一个 DML 操作，就要对受影响的行加排他锁，这样就不允许再加别的锁，也就是说别的会话不 能修改这些行。同时为了避免在做这个 DML 操作的时候，有别的会话执行 DDL，修改表的定义， 所以要在表上加共享锁，这样就阻止了 DDL 的操作。?
> \4. 当执行 DDL 操作时，就需要在全表上加排他锁

```
数据库死锁的原因
```

> - 若干事务相互等待对方释放封锁，就陷入了无限期等待状态，系统进入死锁。
> - 表级锁不会产生死锁。所以解决死锁主要还是针对于最常用的 InnoDB.

```
解除数据库死锁的方法
```

> - 允许死锁发生，然后解除它，如果发现死锁，则将其中一个代价较小的事务撤销，回滚这个事务，并释放此事务持有的封锁，使其他事务继续进行。
> - 死锁解决：先找到死锁的线程号，然后杀掉线程 ID

------

## 怎么防止 form 表单多次提交？

```
背景与介绍
```

> - 为由于用户误操作，多次点击表单提交按钮。
> - 由于网速等原因造成页面卡顿，用户重复刷新提交页面。
> - 黑客或恶意用户使用 postman 等工具重复恶意提交表单（攻击网站）。

```
如何防止
```

> 1、禁掉提交按钮
> 表单提交后使用 Javascript 使提交按钮 disable。这种方法防止心急的用户多次点击按钮。但有个问题，如果客户端把 Javascript 给禁止掉，这种方法就无效了。
> 2、Post/Redirect/Get 模式
> 在提交后执行页面重定向，这就是所谓的 Post-Redirect-Get (PRG) 模式。简言之，当用户提交了表单后，你去执行一个客户端的重定向，转到提交成功信息页面。
> 这能避免用户按 F5 导致的重复提交，而其也不会出现浏览器表单重复提交的警告，也能消除按浏览器前进和后退按导致的同样问题。
> 3、在 session 中存放一个特殊标志
> 当表单页面被请求时，生成一个特殊的字符标志串，存在 session 中，同时放在表单的隐藏域里。接受处理表单数据时，检查标识字串是否存在，并立即从 session 中删除它，然后正常处理数据。如果发现表单提交里没有有效的标志串，这说明表单已经被提交过了，忽略这次提交。这使你的 web 应用有了更高级的 XSRF 保护。
> 4、使用 Cookie 处理
> 使用 Cookie 记录表单提交的状态，根据其状态可以检查是否已经提交表单。
> 5、在数据库里添加约束
> 在数据库里添加唯一约束或创建唯一索引，防止出现重复数据。这是最有效的防止重复提交数据的方法。

------

## 如何得到当前执行脚本路径，包括得到的参数？

> 当前执行脚本路径：使用魔术常量：**FILE**

```
手册解释
```

> - 文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。自 PHP 4.0.2 起，**FILE** 总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。
> - 包括所得到参数
> - $_GET 包括 get 请求的参数，$_POST 包括 post 请求的参数，如果需要解析路径中的参数可以使用函数 pathinfo (string $path)

------

## 客户端打开网页是空白页的原因分析几种？

因更换服务器（硬件）或系统引发的缓存不一致或异常（缓存引发空白）；
`解决方案`

> 1、如果您的网站管理后台可以正常登陆，可以到管理后台进行清空缓存或更新缓存操作，一般可以恢复；
> 2、如果上面操作不能解决问题，而您的网站程序属于可安装的模版程序，可以偿试重新安装网站程序（重装前，为了数据安全，建议备份网站和数据库）
> 3、如果上面两步还不能解决，可以偿试重启 IIS 或服务器偿试；
> 4、上面三步全做了，依然不能解决问题，基本可以排除缓存引发的空白，另找其它可能产生该问题的原因。

因数据库链接错误引发的网页显示空白；
`解决方案`

> 1、找到数据库链接文件，修改为正常的数据库链接；
> 2、个别网站系统可能对文件编码有要求，直接使用文本编辑数据库链接文件，也可能会导致数据库链接不成功而显示空白，可以偿试用 Macromedia Dreamweaver 之类的编辑软件对源文件进行修改。

因部分函数被禁用，或文件不全，程序错误引发的网页显示空白；
`解决方案`

> 1、首先要找到具体的错误提示
> 错误提示，一般有两种方法可以看到
> 一种是查看错误日志文件，快网 VPS 默认记录在：D:\PHPLOG\php-errors.log，打开该文件，分析错误日志
> 如果您的 php.ini 中，没有配制记录错误日志，可以手动打开，具体方法如下：
> 先找到 php.ini 这个文件，一般放在 PHP 的安装目录，快网 VPS 默认安装在：C:\Program Files\PHP
> 用记事本打开 php.ini，找到：error_log= **项目，该项目是指示错误日志的记录路径；找到：log_errors =** 项目，该项目决定是否记录错误日志，On 代表记录，Off 代表关闭；
> 另一种是直接打开网页的错误提示：
> 找到 php.ini，用记事本打开；
> 找到：display_errors = *** 项目，该项目一般默认为 Off，代表关闭错误显示，可以将其修改为 On 来打开错误显示
> 特别说明：修改 php.ini 文件后，需要重启 IIS 才能生效！！！
> 2、找到具体的错误提示后，就可以分析原因了，一般报错是英文，如果您不太懂英文，可以到 google 翻译后，针对性解决问题！！！
> 一般可能出现的问题主要集中在:
> 少文件或文件为 0 字节，说明在上传过程中出现了错误，或有病毒，被杀毒软件处理掉了，这种情况可以重新上传相关文件来解决！

------

## 什么是高内聚低耦合？

> `起因`：模块独立性指每个模块只完成系统要求的独立子功能，并且与其他模块的联系最少且接口简单，两个定性的度量标准――耦合性和内聚性。
>
> - 耦合性也称块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。
> - 耦合性分类 (低――高): 无直接耦合；数据耦合；标记耦合；控制耦合；公共耦合；内容耦合；
> - 1 无直接耦合:
> - 2 数据耦合：指两个模块之间有调用关系，传递的是简单的数据值，相当于高级语言的值传递；
> - 3 标记耦合：指两个模块之间传递的是数据结构，如高级语言中的数组名、记录名、文件名等这些名字即标记，其实传递的是这个数据结构的地址；
> - 4 控制耦合：指一个模块调用另一个模块时，传递的是控制变量（如开关、标志等），被调模块通过该控制变量的值有选择地执行块内某一功能；
> - 5 公共耦合：指通过一个公共数据环境相互作用的那些模块间的耦合。公共耦合的复杂程序随耦合模块的个数增加而增加。
> - 6 内容耦合：这是最高程度的耦合，也是最差的耦合。当一个模块直接使用另一个模块的内部数据，或通过非正常入口而转入另一个模块内部。
> - 内聚性又称块内联系。指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高。
> - 内聚性匪类 (低――高): 偶然内聚；逻辑内聚；时间内聚；通信内聚；顺序内聚；功能内聚；
> - 1 偶然内聚：指一个模块内的各处理元素之间没有任何联系。
> - 2 逻辑内聚：指模块内执行几个逻辑上相似的功能，通过参数确定该模块完成哪一个功能。
> - 3 时间内聚：把需要同时执行的动作组合在一起形成的模块为时间内聚模块。
> - 4 通信内聚：指模块内所有处理元素都在同一个数据结构上操作（有时称之为信息内聚），或者指各处理使用相同的输入数据或者产生相同的输出数据。
> - 5 顺序内聚：指一个模块中各个处理元素都密切相关于同一功能且必须顺序执行，前一功能元素输出就是下一功能元素的输入。
> - 6 功能内聚：这是最强的内聚，指模块内所有元素共同完成一个功能，缺一不可。与其他模块的耦合是最弱的。
> - 耦合性与内聚性是模块独立性的两个定性标准，将软件系统划分模块时，尽量做到高内聚低耦合，提高模块的独立性，为设计高质量的软件结构奠定基础。
> - 有个例子很容易明白：一个程序有 50 个函数，这个程序执行得非常好；然而一旦你修改其中一个函数，其他 49 个函数都需要做修改，这就是高耦合的后果。
> - 一旦你理解了它，你编写概要设计的时候设计类或者模块自然会考虑到 “高内聚，低耦合”

------

## Linux 下建立压缩包，解压缩包的命令

> - 压缩：tar -czvf FileName.tar DirName
> - 解压：tar -zxvf FileName.tar.gz

------

## 百万级以上的数据表，分页面临哪些额问题？如何构建高效的 mysql 分页功能？

1、将 LIMIT M,N 的查询改为 LIMIT N

> 例如，使用 LIMIT 10000,20，Mysql 将需要读取前 10000 行，然后获取后面的 20 行 ，这是非常低效的，使用 LIMIT N 的方式，通过每页第一条或最后一条记录的 id 来做条件筛选，再配合降序和升序获得上 / 下一页的结果集 。

2、限制用户翻页数量

> 产品实际使用过程中用户很少关心搜索结果的第 1 万条数据。

3、使用延迟关联

> 通过使用覆盖索引来查询返回需要的主键，再根据返回的主键关联原表获得需要的行，这样可以减少 Mysql 扫描那些需要丢弃的行数。

------

## 数据库内连接，外链接的区别

> 内连接，也被称为自然连接，只有两个表相匹配的行才能在结果集中出现。返回的结果集选取了两个表中所有相匹配的数据，舍弃了不匹配的数据。由于内连接是从结果表中删除与其他连接表中没有匹配的所有行，所以内连接可能会造成信息的丢失。内连接语法如下：
>
> ```php
> select fieldlist from table1 [inner] join table2 on table1.column = table2.column
> ```
>
> - 内连接是保证两个表中所有行都满足连接条件，而外连接则不然。
> - 外连接不仅包含符合连接条件的行，还包含左表 (左连接时)、右表 (右连接时) 或两个边接表 (全外连接) 中的所有数据行。SQL 外连接共有三种类型：左外连接 (关键字为 LEFT OUTER JOIN)、右外连接 (关键字为 RIGHT OUTER JOIN) 和全外连接 (关键字为 FULL OUTER JOIN)。外连接的用法和内连接一样，只是将 INNER JOIN 关键字替换为相应的外连接关键字即可。
> - 内连接：指连接结果仅包含符合连接条件的行，参与连接的两个表都应该符合连接条件。
> - 外连接：连接结果不仅包含符合连接条件的行同时也包含自身不符合条件的行。包括左外连接、右外连接和全外连接。
> - 左外连接：左边表数据行全部保留，右边表保留符合连接条件的行。
> - 右外连接：右边表数据行全部保留，左边表保留符合连接条件的行。
> - 全外连接：左外连接 union 右外连接。

------

## 解析一下数据库名词：主键，存储过程，视图，事务

> - 主键：能够唯一表示数据表中的每个记录的【字段】或者【字段】的组合就称为主码 (主键)。一个主键是唯一识别一个表的每一记录，但这只是其作用的一部分，主键的主要作用是将记录和存放在其他表中的数据进行关联。在这一点上，主键是不同表中各记录之间的简单指针。主键约束就是确定表中的每一条记录。主键不能是空值。唯一约束是用于指定一个或多个列的组合值具有唯一性，以防止在列中输入重复的值。所以，主键的值对用户而言是没有什么意义，并且和它要赋予的值也没有什么特别的联系。
> - 事务：事务是一组原子操作单元，从数据库角度说，就是一组 SQL 指令，要么全部执行成功，若因为某个原因其中一条指令执行有错误，则撤销先前执行过的所有指令。更简答的说就是：要么全部执行成功，要么撤销不执行。
> - 存储过程：存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的 SQL 语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。
> - 视图：视图是一张虚拟表，它表示一张表的部分数据或多张表的综合数据，其结构和数据是建立在对表的查询基础上。视图中并不存放数据，而是存放在视图所引用的原始表（基表）中同一张原始表，根据不同用户的不同需求，可以创建不同的视图

------

## 描述对 mysql 连接池的理解？

> - 官方：数据库连接池（Connection pooling）是程序启动时建立足够的数据库连接，并将这些连接组成一个连接池，由程序动态地对池中的连接进行申请，使用，释放。
> - 个人理解：创建数据库连接是一个很耗时的操作，也容易对数据库造成安全隐患。所以，在程序初始化的时候，集中创建多个数据库连接，并把他们集中管理，供程序使用，可以保证较快的数据库读写速度，还更加安全可靠。

数据库连接池的运行机制

> （1） 程序初始化时创建连接池
> （2） 使用时向连接池申请可用连接
> （3） 使用完毕，将连接返还给连接池
> （4） 程序退出时，断开所有连接，并释放资源

------

## 为何要使用数据库连接池？

> - 假设网站一天有很大的访问量，数据库服务器就需要为每次连接创建一次数据库连接，极大的浪费数据库的资源，并且极易造成数据库服务器内存溢出、拓机。
> - 数据库连接是一种关键的有限的昂贵的资源，这一点在多用户的网页应用程序中体现的尤为突出。对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。数据库连接池正式针对这个问题提出来的。数据库连接池负责分配，管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。
> - 数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中.

------

## 使用数据库连接池的关键点？

1、并发问题

> 　　为了使连接管理服务具有最大的通用性，必须考虑多线程环境，即并发问题。这个问题相对比较好解决，因为各个语言自身提供了对并发管理的支持像 java,c# 等等，使用 synchronized (java) lock (C#) 关键字即可确保线程是同步的。使用方法可以参考，相关文献。

２、事务处理

> - DB 连接池必须要确保某一时间内一个 conn 只能分配给一个线程。不同 conn 的事务是相互独立的。
> - 　　我们知道，事务具有原子性，此时要求对数据库的操作符合 “ALL-ALL-NOTHING” 原则，即对于一组 SQL 语句要么全做，要么全不做。
> - 　　我们知道当２个线程共用一个连接 Connection 对象，而且各自都有自己的事务要处理时候，对于连接池是一个很头疼的问题，因为即使 Connection 类提供了相应的事务支持，可是我们仍然不能确定那个数据库操作是对应那个事务的，这是由于我们有２个线程都在进行事务操作而引起的。为此我们可以使用每一个事务独占一个连接来实现，虽然这种方法有点浪费连接池资源但是可以大大降低事务管理的复杂性。

３、连接池的分配与释放

> - 　　连接池的分配与释放，对系统的性能有很大的影响。合理的分配与释放，可以提高连接的复用度，从而降低建立新连接的开销，同时还可以加快用户的访问速度。
> - 　　对于连接的管理可使用一个 List。即把已经创建的连接都放入 List 中去统一管理。每当用户请求一个连接时，系统检查这个 List 中有没有可以分配的连接。如果有就把那个最合适的连接分配给他（如何能找到最合适的连接文章将在关键议题中指出）；如果没有就抛出一个异常给用户，List 中连接是否可以被分配由一个线程来专门管理捎后我会介绍这个线程的具体实现。

４、连接池的配置与维护

> - 　　连接池中到底应该放置多少连接，才能使系统的性能最佳？系统可采取设置最小连接数（minConnection）和最大连接数（maxConnection）等参数来控制连接池中的连接。比方说，最小连接数是系统启动时连接池所创建的连接数。如果创建过多，则系统启动就慢，但创建后系统的响应速度会很快；如果创建过少，则系统启动的很快，响应起来却慢。这样，可以在开发时，设置较小的最小连接数，开发起来会快，而在系统实际使用时设置较大的，因为这样对访问客户来说速度会快些。最大连接数是连接池中允许连接的最大数目，具体设置多少，要看系统的访问量，可通过软件需求上得到。
> - 　　如何确保连接池中的最小连接数呢？有动态和静态两种策略。动态即每隔一定时间就对连接池进行检测，如果发现连接数量小于最小连接数，则补充相应数量的新连接，以保证连接池的正常运转。静态是发现空闲连接不够时再去检查。

------

------

## 使用数据库连接池的优势？

1、连接池的优势

> 连接池用于创建和管理数据库连接的缓冲池技术，缓冲池中的连接可以被任何需要他们的线程使用。当一个线程需要用 JDBC 对一个数据库操作时，将从池中请求一个连接。当这个连接使用完毕后，将返回到连接池中，等待为其他的线程服务。

连接池的主要优点有以下三个方面。

> - 第一、减少连接创建时间。连接池中的连接是已准备好的、可重复使用的，获取后可以直接访问数据库，因此减少了连接创建的次数和时间。
> - 第二、简化的编程模式。当使用连接池时，每一个单独的线程能够像创建一个自己的 JDBC 连接一样操作，允许用户直接使用 JDBC 编程技术。
> - 第三、控制资源的使用。如果不使用连接池，每次访问数据库都需要创建一个连接，这样系统的稳定性受系统连接需求影响很大，很容易产生资源浪费和高负载异常。连接池能够使性能最大化，将资源利用控制在一定的水平之下。连接池能控制池中的连接数量，增强了系统在大量用户应用时的稳定性。
> - 连接池的工作原理？

下面，简单的阐述下连接池的工作原理。

> 连接池技术的核心思想是连接复用，通过建立一个数据库连接池以及一套连接使用、分配和管理策略，使得该连接池中的连接可以得到高效、安全的复用，避免了数据库连接频繁建立、关闭的开销。

连接池的工作原理主要由三部分组成，分别为连接池的建立、连接池中连接的使用管理、连接池的关闭。

> - 第一、连接池的建立。一般在系统初始化时，连接池会根据系统配置建立，并在池中创建了几个连接对象，以便使用时能从连接池中获取。连接池中的连接不能随意创建和关闭，这样避免了连接随意建立和关闭造成的系统开销。Java 中提供了很多容器类可以方便的构建连接池，例如 Vector、Stack 等。
> - 第二、连接池的管理。连接池管理策略是连接池机制的核心，连接池内连接的分配和释放对系统的性能有很大的影响。其管理策略是：
> - 当客户请求数据库连接时，首先查看连接池中是否有空闲连接，如果存在空闲连接，则将连接分配给客户使用；如果没有空闲连接，则查看当前所开的连接数是否已经达到最大连接数，如果没达到就重新创建一个连接给请求的客户；如果达到就按设定的最大等待时间进行等待，如果超出最大等待时间，则抛出异常给客户。
> - 当客户释放数据库连接时，先判断该连接的引用次数是否超过了规定值，如果超过就从连接池中删除该连接，否则保留为其他客户服务。
> - 该策略保证了数据库连接的有效复用，避免频繁的建立、释放连接所带来的系统资源开销。
> - 第三、连接池的关闭。当应用程序退出时，关闭连接池中所有的连接，释放连接池相关的资源，该过程正好与创建相反

常用的连接池：

- dbcp 可能是使用最多的开源连接池，原因大概是因为配置方便，而且很多开源和 tomcat 应用例子都是使用的这个连接池吧。这个连接池可以设置最大和最小连接，连接等待时间等，基本功能都有。这个连接池的配置在具体项目应用中，发现此连接池的持续运行的稳定性还是可以，不过速度稍慢，在大并发量的压力下稳定性

------

## 事物的四大特性和事物的隔离级别 锁之间的区别？

如果一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性（ACID）:

⑴ 原子性（Atomicity）

> 　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

⑵ 一致性（Consistency）

> - 　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。
> - 　　拿转账来说，假设用户 A 和用户 B 两者的钱加起来一共是 5000，那么不管 A 和 B 之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是 5000，这就是事务的一致性。

⑶ 隔离性（Isolation）

> - 　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
> - 　　即要达到这么一种效果：对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。
> - 　　关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。

⑷ 持久性（Durability）

> - 　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。
> - 　　例如我们在使用 JDBC 操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。

------

> 当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题：

1，脏读

> 脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。

2，不可重复读

> 不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。

3，虚读（幻读）

> 幻读是事务非独立执行时发生的一种现象。例如事务 T1 对一个表中所有的行的某个数据项做了从 “1” 修改为 “2” 的操作，这时事务 T2 又对这个表中插入了一行数据项，而这个数据项的数值还是为 “1” 并且提交给数据库。而操作事务 T1 的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务 T2 中添加的，就好像产生幻觉一样，这就是发生了幻读。

现在来看看 MySQL 数据库为我们提供的四种隔离级别：

> 　　① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。
> 　　② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。
> 　　③ Read committed (读已提交)：可避免脏读的发生。
> 　　④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。

　　以上四种隔离级别最高的是 Serializable 级别，最低的是 Read uncommitted 级别，当然级别越高，执行效率就越低。像 Serializable 这样的级别，就是以锁表的方式 (类似于 Java 多线程中的锁) 使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在 MySQL 数据库中默认的隔离级别为 Repeatable read (可重复读)。

一般可以分为两类，一个是悲观锁，一个是乐观锁，悲观锁一般就是我们通常说的数据库锁机制，乐观锁一般是指用户自己实现的一种锁机制，比如 hibernate 实现的乐观锁甚至编程语言也有乐观锁的思想的应用。
1、悲观锁

> 悲观锁：顾名思义，就是很悲观，它对于数据被外界修改持保守态度，认为数据随时会修改，所以整个数据处理中需要将数据加锁。悲观锁一般都是依靠关系数据库提供的锁机制，事实上关系数据库中的行锁，表锁不论是读写锁都是悲观锁。

悲观锁按照使用性质划分：

> - 共享锁（Share locks 简记为 S 锁）：也称读锁，事务 A 对对象 T 加 s 锁，其他事务也只能对 T 加 S，多个事务可以同时读，但不能有写操作，直到 A 释放 S 锁。
> - 排它锁（Exclusivelocks 简记为 X 锁）：也称写锁，事务 A 对对象 T 加 X 锁以后，其他事务不能对 T 加任何锁，只有事务 A 可以读写对象 T 直到 A 释放 X 锁。
> - 更新锁（简记为 U 锁）：用来预定要对此对象施加 X 锁，它允许其他事务读，但不允许再施加 U 锁或 X 锁；当被读取的对象将要被更新时，则升级为 X 锁，主要是用来防止死锁的。因为使用共享锁时，修改数据的操作分为两步，首先获得一个共享锁，读取数据，然后将共享锁升级为排它锁，然后再执行修改操作。这样如果同时有两个或多个事务同时对一个对象申请了共享锁，在修改数据的时候，这些事务都要将共享锁升级为排它锁。这些事务都不会释放共享锁而是一直等待对方释放，这样就造成了死锁。如果一个数据在修改前直接申请更新锁，在数据修改的时候再升级为排它锁，就可以避免死锁。

悲观锁按照作用范围划分：

> - 行锁：锁的作用范围是行级别，数据库能够确定那些行需要锁的情况下使用行锁，如果不知道会影响哪些行的时候就会使用表锁。举个例子，一个用户表 user，有主键 id 和用户生日 birthday 当你使用 update … where id=? 这样的语句数据库明确知道会影响哪一行，它就会使用行锁，当你使用 update … where birthday=? 这样的的语句的时候因为事先不知道会影响哪些行就可能会使用表锁。
> - 表锁：锁的作用范围是整张表。

乐观锁

> 乐观锁：顾名思义，就是很乐观，每次自己操作数据的时候认为没有人回来修改它，所以不去加锁，但是在更新的时候会去判断在此期间数据有没有被修改，需要用户自己去实现。既然都有数据库提供的悲观锁可以方便使用为什么要使用乐观锁呢？对于读操作远多于写操作的时候，大多数都是读取，这时候一个更新操作加锁会阻塞所有读取，降低了吞吐量。最后还要释放锁，锁是需要一些开销的，我们只要想办法解决极少量的更新操作的同步问题。换句话说，如果是读写比例差距不是非常大或者你的系统没有响应不及时，吞吐量瓶颈问题，那就不要去使用乐观锁，它增加了复杂度，也带来了额外的风险。

乐观锁实现方式：

> - 版本号（记为 version）：就是给数据增加一个版本标识，在数据库上就是表中增加一个 version 字段，每次更新把这个字段加 1，读取数据的时候把 version 读出来，更新的时候比较 version，如果还是开始读取的 version 就可以更新了，如果现在的 version 比老的 version 大，说明有其他事务更新了该数据，并增加了版本号，这时候得到一个无法更新的通知，用户自行根据这个通知来决定怎么处理，比如重新开始一遍。这里的关键是判断 version 和更新两个动作需要作为一个原子单元执行，否则在你判断可以更新以后正式更新之前有别的事务修改了 version，这个时候你再去更新就可能会覆盖前一个事务做的更新，造成第二类丢失更新，所以你可以使用 update … where … and version=”old version” 这样的语句，根据返回结果是 0 还是非 0 来得到通知，如果是 0 说明更新没有成功，因为 version 被改了，如果返回非 0 说明更新成功。
> - 时间戳（timestamp）：和版本号基本一样，只是通过时间戳来判断而已，注意时间戳要使用数据库服务器的时间戳不能是业务系统的时间。
> - 待更新字段：和版本号方式相似，只是不增加额外字段，直接使用有效数据字段做版本控制信息，因为有时候我们可能无法改变旧系统的数据库表结构。假设有个待更新字段叫 count, 先去读取这个 count, 更新的时候去比较数据库中 count 的值是不是我期望的值（即开始读的值），如果是就把我修改的 count 的值更新到该字段，否则更新失败。java 的基本类型的原子类型对象如 AtomicInteger 就是这种思想。
> - 所有字段：和待更新字段类似，只是使用所有字段做版本控制信息，只有所有字段都没变化才会执行更新。

------

## 怎么改 session 存储位置？

> - 使用 phpinfo () 查看 PHP 的配置信息，定位配置文件的路径
> - Loaded Configuration File，的值即是 PHP 配置文件的路径
> - 在配置文件中查找：session.save_path，并修改其值
> - 重启 Apache 服务器

------

## Memcache 的存储原理和 lru 机制？

memcache 的内存分配机制：

- memcache 进程会预先分配一部分内存给 slab，给 slab 分配的内存也叫 page（page 的默认大小是 1M），每个 page 下面会有若干个 chunk（chunk 默认大小 96B），而数据就会封装成 item 存储在 chunk 里面，若干个大小相同的 chunk 称为 slab class，相同大小的 chunk 未必在一个 slab 中。所以在默认情况下一个 slab 存放的 chunk 数量为 10922 个 chunk：10922×96+ 64 = 1048576（1M） 。
- 但是在一个 slab 中所有的 chunk 的大小是不同的，不同大小的 chunk 存放不同大小的数据。

memcache 的数据删除机制：

> - 当数据过期时，memcache 并不会直接从内存中删除数据，因为 memcache 并不会回收已经分配的内存，而只是在 get 数据时检查时间戳是否过期，如果过期那么客户端就不可见，但是原来分配的内存可以重复使用，这叫做惰性失效。所以 memcache 不会对过期的数据进行监视，因此也就节省了 cpu 的资源。
> - 但是在 memcache 中使用 LRU 机制进行删除数据，即最近最少使用。通过计数器来记录哪些数据最少被使用来删除它，所以也有可能删除一些尚未过期或者永久有效的数据。
> - 在每个 slab 中数据都是存放在链表上的，链表有 head 和 tail 指针，分别指向最老和最新的数据。当 LRU 机制启动时，两个指针同时发挥作用查询失效数据，如果没有失效数据那么就会删除最近的最少被使用的数据。
> - LRU 只针对每个 slab，并不针对整体。只有在 slab 不能分配新的 page 内存时才会调用 LRU。

------

## 一种有效缓解使用 LRU 的方法是：

1，避免大对象

> 如果系统上只有及个别几个大对象的话，会浪费内存空间，因为 Slab 申请了 Page 是不能释放内存的，及个别大对象会导致 Slab 申请了内存资源而得不到充分的利用。

2，调整增长因子

> 根据项目的需求调整增长因子，使内存充分利用。

------

## 对于大流量的网站？采用什么方法解决访问量的问题优化程序，优化数据库，如何程序和数据库已经最优化，使用以下解决方法？

硬件方面

> 普通的一个 p4 的服务器每天最多能支持大约 10 万左右的 IP，主要影响服务器的速度有：网络 - 硬盘读写速度 - 内存大小 - cpu 处理速度。

软件方面

> - 静态页面 前台实现完全的静态化当然最好，可以完全不用访问数据库
> - 数据库优化
> - 表字段优化
> - 语句优化
> - 索引优化
> - 分库分表
> - 读写分离

禁止外部的盗链

> - 外部盗链往往会加大服务器的请求和流量的负载压力，因此应该严格限制外部对于自身的图片或者文件盗链，
> - 好在目前可以简单地通过 refer 来控制盗链，
> - Apache 自己就可以通过配置来禁止盗链
> - IIS 也有一些第三方的 ISAPI 可以实现同样的功能。
> - 或者使用非技术手段来解决，比如在图片上增加水印

控制大文件的下载。

- 大文件的下载会占用很大的流量，并且对于非 SCSI 硬盘来说，大量文件下载会消耗
- CPU，使得网站响应能力下降。因此，尽量不要提供超过 2M 的大文件下载，如果需要
- 提供，建议将大文件放在另外一台服务器上

使用不同主机分流主要流量

> - 将文件放在不同的主机上，提供不同的镜像供用户下载。比如如果觉得 RSS 文件占用
> - 流量大，那么使用 FeedBurner 或者 FeedSky 等服务将 RSS 输出放在其他主机上，这
> - 样别人访问的流量压力就大多集中在 FeedBurner 的主机上，RSS 就不占用太多资源了

使用流量分析统计软件。

> 在网站上安装一个流量分析统计软件，可以即时知道哪些地方耗费了大量流量，哪些页面需要再进行优化，因此，解决流量问题还需要进行精确的统计分析才可以。比如：Google Analytics（Google 分析）。

------

## 变量与常量有哪些区别？（必做）

> - 1. 常量前面没有美元符号（$）
> - 1. 常量只能用 define () 函数定义，而不能通过赋值语句
> - 1. 常量可以不用理会变量范围的规则而在任何地方定义和访问
> - 1. 常量一旦定义就不能被重新定义或者取消定义
> - 1. 常量的值只能是标量
> - 常量前面没有 $
> - 两者的作用域不同，变量的定义和访问有作用域的限制，常量可在任何地方定义与访问
> - 常量一旦定义不可更改或取消定义他的值只是标量
> - 常量只能通过 define () 函数定义，而不能同过赋值定义

------

## 数据库索引是什么？有什么优点和缺点

> 索引就像是书的目录，是与表或视图关联的磁盘上结构，可以加快从表或视图中检索行的速度。索引中包含由表或视图中的一列或多列生成的键。这些键存储在一个结构（BTree）中，使 SQL 可以快速有效地查找与键值关联的行。

优点：

> ① 建立索引的列可以保证行的唯一性，生成唯一的 rowId
> ② 建立索引可以有效缩短数据的检索时间
> ③ 建立索引可以加快表与表之间的连接
> ④ 为用来排序或者是分组的字段添加索引可以加快分组和排序顺序

缺点：

> ① 创建索引和维护索引需要时间成本，这个成本随着数据量的增加而加大
> ② 创建索引和维护索引需要空间成本，每一条索引都要占据数据库的物理存储空间，数据量越大，占用空间也越大（数据表占据的是数据库的数据空间）
> ③ 会降低表的增删改的效率，因为每次增删改索引需要进行动态维护，导致时间变长

------

## 数据库的性能优化主要包含哪些方面

> - 1、sql 语句的执行计划是否正常
> - 2、减少应用和数据库的交互次数、同一个 sql 语句的执行次数
> - 3、数据库实体的碎片的整理（特别是对某些表经常进行 insert 和 delete 动作，尤其注意，索引字段为系列字段、自增长字段、时间字段，对于业务比较频繁的系统，最好一个月重建一次）
> - 4、减少表之间的关联，特别对于批量数据处理，尽量单表查询数据，统一在内存中进行逻辑处理，减少数据库压力（java 处理批量数据不可取，尽量用 c 或者 c++ 进行处理，效率大大提升）
> - 5、对访问频繁的数据，充分利用数据库 cache 和应用的缓存
> - 6、数据量比较大的，在设计过程中，为了减少其他表的关联，增加一些冗余字段，提高查询性能

------

## 设计和创建无限极分类的数据表结构

信息表

```php
`ID` int(10) unsigned NOT NULL auto_increment, 
`cID` tinyint(3) unsigned NOT NULL default '0', 
`title` varchar(255) NOT NULL default 'No Title', 
`content` mediumtext NOT NULL, 
```

分类表

```php
`cID` tinyint(3) unsigned NOT NULL auto_increment, 
`parentID` tinyint(3) unsigned NOT NULL default '0', 
`order` tinyint(3) NOT NULL default '0', 
`name` varchar(255) NOT NULL default '',  
```

------

## 请设计用户登录功能，尽量完整的写出 from 表单，并设计用户表 tb_user，其中含字段 id,name ,pwd，写一高效 sql 语句，用于匹配用户表中用户名和密码是否正确。

```php
$info = self::(‘id’,’name’,’pwd’)
->where(‘name’,$username)
->where(‘pwd’,$pwd)
->first();
Create table tb_user(
Id int(11) unsigned primary key auto_increment comment ‘主键id’,
Name varchar(50) not null comment ‘姓名’,
Pwd varchar(50) not null comment ‘密码’
)ENGINE = MYISAM DEFAULT CHARSET=utf8 COLLATE=utf8_general_ci;
```

------

## Left join right join inner join 的区别是什么？

> - left join (左连接) 返回包括左表中的所有记录和右表中连接字段相等的记录
> - right join (右连接) 返回包括右表中的所有记录和左表中连接字段相等的记录
> - 左连接和右连接很相似，只是左右表位置的不同罢了。适用场景，如：员工表中有个字段是详细地址信息表的主键 id，这两个表相关联时，就可以用左连接或右连接，因为在详细地址信息表中找不到某员工的地址信息也要将员工这条记录显示出来，相应的详细地址信息字段为空即可，而不能因为地址没有存在数据库里，这个员工就没了（简单理解成不重要的信息不影响整条记录的显示）
> - inner join (等值连接、内连接) 只返回两个表中连接字段相等的行
> - 内连接的适用场景：相连接的两个表中必须在某个字段上有相等的值才可以将整条记录显示出来，如一条服务单记录在了两个表中，A 表中记录了该服务单的服务时间、坐席名称和录音地址等基本信息，B 表中记录了该服务单的业务详情，如保险单号，车牌号，保单日期等，当显示该服务单时，要将 A 表与 B 表做内连接，因为少这两表任何一个表，该服务单都不算完整，缺失的信息会使业务上没法继续。
>
> 总结：可以将可使用左连接和右连接的两个表理解成其中一个表的信息明显比另外一个表的信息重要得多；使用内连接的两个表理解成重要程度区别不太大的两个表。

------

## 描述 sql 语句的执行顺序？

> - 1、 from 子句组装来自不同数据源的数据；
> - 2、where 子句基于指定的条件对记录行进行筛选；
> - 3、group by 子句将数据划分为多个分组；
> - 4、使用聚集函数进行计算；
> - 5、使用 having 子句筛选分组；
> - 6、计算所有的表达式；
> - 7、使用 order by 对结果集进行排序。

select 集合输出。

> 1）语法分析，分析语句的语法是否符合规范，衡量语句中各表达式的意义。
> 2）语义分析，检查语句中涉及的所有数据库对象是否存在，且用户有相应的权限。
> 3）视图转换，将涉及视图的查询语句转换为相应的对基表查询语句。
> 4）表达式转换， 将复杂的 SQL 表达式转换为较简单的等效连接表达式。
> 5）选择优化器，不同的优化器一般产生不同的 “执行计划”
> 6）选择连接方式， ORACLE 有三种连接方式，对多表连接 ORACLE 可选择适当的连接方式。
> 7）选择连接顺序， 对多表连接 ORACLE 选择哪一对表先连接，选择这两表中哪个表做为源数据表。
> 8）选择数据的搜索路径，根据以上条件选择合适的数据搜索路径，如是选用全表搜索还是利用索引或是其他的方式。
> 9）运行 “执行计划”

------

## Linux 下如何查看 IO 负载？

第一种：用 top 命令 中的 cpu 信息观察

> Top 可以看到的 cpu 信息会有：0.0% wa 的百分比可以大致的体现出当前的磁盘 io 请求是否频繁。如果 wa 的数量比较大，说明等待输入输出的的 io 比较多。

第二种：用 vmstat 命令报告

> - IO 参数
> - 　　bi: 发送到块设备的块数，单位：块 / 秒
> - bo: 从块设备接收到的块数，单位：块 / 秒
> - r: 等待运行的进程数 b: 处在非中断睡眠状态的进程数
> - 输入命令：vmstat 2 5
> - 　　如果发现等待的进程和处在非中断睡眠状态的进程数非常多，并且发送到块设备的块数和从块设备接收到的块数非常大，那就说明磁盘 io 比较多。

第三种 ps -aux

> - Linxu 下如何给一个目录以及子目录，文件更该用户组合文件权限？
> - chmod -R abc 目录名
> - 其中 a,b,c 各为一个数字，分别表示 User、Group、及 Other 的权限。
> - r=4，w=2，x=1

------

## 对一个目录来说，rwx 分别代表什么含义？

> - r (Read，读取)：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权限。
> - w (Write, 写入)：对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。
> - x (eXecute，执行)：对文件而言，具有执行文件的权限；对目录了来说该用户具有进入目录的权限。
> - 也就是说，如果对一个目录具有写权限，但是这个目录下的文件却只有读权限，最终的结果是，你可以删除这个文件，但是无法修改它！

------

## Mysql 中 explain 方法的参数和使用方法？

> MySQL 常见的性能瓶颈一般都是出现在 CPU 和 I/O 上，即在数据装入内存中或磁盘上读取数据时，CPU 发生了饱和或装入数据过大，内存容量不足，磁盘 I/O 性能被限制。这时候就要使用到 Explain 关键字来进行分析和调优。

基本使用

> - Explain 关键字可以用来模拟优化器执行 SQL 查询语句，从而了解 SQL 语句的处理方式，来达到分析查询语句或表结构的性能瓶颈。
> - 通过 Explain 可以获得
> - 表的读取顺序和引用
> - 数据读取操作的基本类型
> - 可使用的索引以及实际使用的索引
> - 优化器的查询行数

------

## 对一个目录来说，rwx 分别代表什么含义？

> - r (Read，读取)：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权限。
> - w (Write, 写入)：对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。
> - x (eXecute，执行)：对文件而言，具有执行文件的权限；对目录了来说该用户具有进入目录的权限。
> - 也就是说，如果对一个目录具有写权限，但是这个目录下的文件却只有读权限，最终的结果是，你可以删除这个文件，但是无法修改它！

------

## 列举出 linux 进程具有哪些属性和数值上限？

> - 基本属性包括：进程号 PID、父进程号 PPID、进程组号 PGID
> - 进程状态：状态分为运行 R、休眠 S、僵尸 Z；
> - 进程执行的优先级；
> - 进程所连接的终端名；
> - 进程资源占用：比如占用资源大小（内存、CPU 占用量）；
> - 列举出 df cat chmod wc awk sed sysct netstat vmstat iostat
> - df 命令用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为 KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。
> - cat 命令连接文件并打印到标准输出设备上，cat 经常用来显示文件的内容
> - chmod 命令用来变更文件或目录的权限。在 UNIX 系统家族里，文件或目录权限的控制分别以读取、写入、执行 3 种一般权限来区分，另有 3 种特殊权限可供运用。
> - wc 命令用来计算数字。利用 wc 指令我们可以计算文件的 Byte 数、字数或是列数，若不指定文件名称，或是所给予的文件名为 “-”，则 wc 指令会从标准输入设备读取数据。
> - awk 命令用于在 linux/unix 下对文本和数据进行处理。数据可以来自标准输入 (stdin)、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是 linux/unix 下的一个强大编程工具 / AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。
> - sed 命令 Stream Editor 文本流编辑，sed 是一个 “非交互式的” 面向字符流的编辑器。能同时处理多个文件多行的内容，可以不对原文件改动，把整个文件输入到屏幕，可以把只匹配到模式的内容输入到屏幕上。还可以对原文件改动，但是不会再屏幕上返回结果。
> - sysctl 命令被用于在内核运行时动态地修改内核的运行参数，可用的内核参数在目录 /proc/sys 中。
> - 它包含一些 TCP/ip 堆栈和虚拟内存系统的高级选项，这可以让有经验的管理员提高引人注目的系统性能。用 sysctl 可以读取设置超过五百个系统变量 / 语法：sysctl (选项)(参数)
> - netstat 命令用来打印 Linux 中网络系统的状态信息，可让你得知整个 Linux 系统的网络情况。
> - vmstat 命令的含义为显示虚拟内存状态（“Viryual Memor Statics”），但是它可以报告关于进程、内存、I/O 等系统整体运行状态。
> - iostat 命令主要通过观察物理磁盘的活动时间以及他们的平均传输速度，监控系统输入 / 输出设备负载。

------

## mysql 字段类型各占几个字节：Smallint int bigint datetime varchar (8)

> - smallint 较小整数 2 字节
> - int 标准整数 4 字节
> - bigint 较大整数 8 字节
> - datetime “yyyy-mm-dd hh:mm:ss” 格式 8 字节
> - varchar (8) 8 个字符，4 个汉字，一个汉字占两个字符

------

## 网站后台数据库权限模型设计？要求设计出想管所有的数据表以及关键字段？

> - 我们都知道，RBAC（Role-Based Access Control，基于角色的访问控制），就是用户通过角色与权限进行关联。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成 “用户 - 角色 - 权限” 的授权模型。在这种模型中，用户与角色之间，角色与权限之间，一般者是多对多的关系。
> - 角色是什么？可以理解为一定数量的权限的集合，权限的载体。例如：一个论坛系统，“超级管理员”、“版主” 都是角色。版主可管理版内的帖子、可管理版内的用户等，这些是权限。要给某个用户授予这些权限，不需要直接将权限授予用户，可将 “版主” 这个角色赋予该用户。
> - 当用户的数量非常大时，要给系统每个用户逐一授权（授角色），是件非常烦琐的事情。这时，就需要给用户分组，每个用户组内有多个用户。除了可给用户授权外，还可以给用户组授权。这样一来，用户拥有的所有权限，就是用户个人拥有的权限与该用户所在用户组拥有的权限之和。
> - 在应用系统中，权限表现成什么？对功能模块的操作，对上传文件的删改，菜单的访问，甚至页面上某个按钮、某个图片的可见性控制，都可属于权限的范畴。有些权限设计，会把功能操作作为一类，而把文件、菜单、页面元素等作为另一类，这样构成 “用户 - 角色 - 权限 - 资源” 的授权模型。而在做数据表建模时，可把功能操作和资源统一管理，也就是都直接与权限表进行关联，这样可能更具便捷性和易扩展性。

这样设计的好处有二：

> - 其一，不需要区分哪些是权限操作，哪些是资源，（实际上，有时候也不好区分，如菜单，把它理解为资源呢还是功能模块权限呢？）。
> - 其二，方便扩展，当系统要对新的东西进行权限控制时，我只需要建立一个新的关联表 “权限 XX 关联表”，并确定这类权限的权限类型字符串。
> - 这里要注意的是，权限表与权限菜单关联表、权限菜单关联表与菜单表都是一对一的关系。（文件、页面权限点、功能操作等同理）。也就是每添加一个菜单，就得同时往这三个表中各插入一条记录。这样，可以不需要权限菜单关联表，让权限表与菜单表直接关联，此时，须在权限表中新增一列用来保存菜单的 ID，权限表通过 “权限类型” 和这个 ID 来区分是种类型下的哪条记录。
> - 随着系统的日益庞大，为了方便管理，可引入角色组对角色进行分类管理，跟用户组不同，角色组不参与授权。例如：某电网系统的权限管理模块中，角色就是挂在区局下，而区局在这里可当作角色组，它不参于权限分配。另外，为方便上面各主表自身的管理与查找，可采用树型结构，如菜单树、功能树等，当然这些可不需要参于权限分配。

------

## MySQL 有多少种日志？

> - MySQL 如何判断一个表的索引是有效的？
> - 使用方法，在 select 语句前加上 explain 就可以了：
> - Explain select surname,first_name form a,b where a.id=b.id
> - Redis 实现队列关键点是什么？用了什么函数？

------

## 个人理解在项目中使用消息队列一般是有如下几个原因：

> - 把瞬间服务器的请求处理换成异步处理，缓解服务器的压力
> - 实现数据顺序排列获取

------

## redis 实现消息队列步骤如下：

> - 1）.redis 函数 rpush,lpop
> - 2）. 建议定时任务入队列
> - 3）创建定时任务出队列

------

## Php 的加密有那些？写出对于的函数以及作用？

MD5 加密：

> - 1.md5 () 默认情况下以 32 字符十六进制数字形式返回散列值，它接受两个参数，第一个为要加密的字符串，第二个为 raw_output 的布尔值，默认为 false，如果设置为 true，md5 () 则会返回原始的 16 位二进制格式报文摘要
> - 2.md5 () 为单向加密，没有逆向解密算法，但是还是可以对一些常见的字符串通过收集，枚举，碰撞等方法破解

Crypt 加密：

> crypt () 接受两个参数，第一个为需要加密的字符串，第二个为盐值（就是加密干扰值，如果没有提供，则默认由 PHP 自动生成）；返回散列后的字符串或一个少于 13 字符的字符串，后者为了区别盐值。

2.crypt () 为单向加密，跟 md5 一样。
Sha1 加密：

> - \1. 跟 md5 很像，不同的是 sha1 () 默认情况下返回 40 个字符的散列值，传入参数性质一样，第一个为加密的字符串，第二个为 raw_output 的布尔值，默认为 false，如果设置为 true，sha1 () 则会返回原始的 20 位原始格式报文摘要
> - 2.sha1 () 也是单行加密，没有逆向解密算法‘

base64 编码加密：

> - 1.base64_encode () 接受一个参数，也就是要编码的数据（这里不说字符串，是因为很多时候 base64 用来编码图片）
> - 2.base64encode () 为双向加密，可用 base64decode () 来解密

------

## 加密类型？

\1. 单向散列加密

> - 　　就是把任意长度的信息进行散列计算，得到固定长度的输出，这个散列计算过程是单向的，即不能对固定长度的输出信息进行计算从而得到输入信息。
> - （1）特征：雪崩效应、定长输出和不可逆。
> - （2）作用是：确保数据的完整性。
> - （3）加密算法：md5（标准密钥长度 128 位）、sha1（标准密钥长度 160 位）、md4、CRC-32

\2. 对称散列加密

> - 　　对称加密是指加密和解密是使用同一个密钥，或者可以互相推算。
> - （1）加密方和解密方使用同一个密钥。
> - （2）加密解密的速度比较快，适合数据比较长时的使用。
> - （3）密钥传输的过程不安全，且容易被破解，密钥管理也比较麻烦。
> - （4）加密算法：DES（Data Encryption Standard）、3DES、AES（Advanced Encryption Standard，支持 128、192、256、512 位密钥的加密）、Blowfish。

\3. 非对称散列加密

> - 　　非对称加密和解密使用的不是同一个密钥，其中一个对外公开，称作公钥，另一个只有所属者知道，称作私钥。
> - （1）每个用户拥用一对密钥加密：公钥和私钥。
> - （2）公钥加密，私钥解密；私钥加密，公钥解密。
> - （3）公钥传输的过程不安全，易被窃取和替换。
> - （4）由于公钥使用的密钥长度非常长，所以公钥加密速度非常慢，一般不使用其去加密。
> - （5）某一个用户用其私钥加密，其他用户用其公钥解密，实现数字签名的作用。
> - （6）公钥加密的另一个作用是实现密钥交换。
> - （7）加密和签名算法：RSA、ELGamal。
> - （8）公钥签名算法：DSA。

------

## Redis 如何切库？redis 如何实现备份的机制？rdb 和 aof 的区别？

区别

> - RDB 持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是 fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。
> - AOF 持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。

二者优缺点
RDB 存在哪些优势呢？

> 1). 一旦采用该方式，那么你的整个 Redis 数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近 24 小时的数据，同时还要每天归档一次最近 30 天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。
> 2). 对于灾难恢复而言，RDB 是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。
> 3). 性能最大化。对于 Redis 的服务进程而言，在开始持久化时，它唯一需要做的只是 fork 出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行 IO 操作了。
> 4). 相比于 AOF 机制，如果数据集很大，RDB 的启动效率会更高。

RDB 又存在哪些劣势呢？

> 1). 如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么 RDB 将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。
> 2). 由于 RDB 是通过 fork 子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是 1 秒钟。

AOF 的优势有哪些呢？

> 1). 该机制可以带来更高的数据安全性，即数据持久性。Redis 中提供了 3 中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。
> 2). 由于该机制对日志文件的写入操作采用的是 append 模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在 Redis 下一次启动之前，我们可以通过 redis-check-aof 工具来帮助我们解决数据一致性的问题。
> 3). 如果日志过大，Redis 可以自动启用 rewrite 机制。即 Redis 以 append 模式不断的将修改数据写入到老的磁盘文件中，同时 Redis 还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行 rewrite 切换时可以更好的保证数据安全性。
> 4). AOF 包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。

AOF 的劣势有哪些呢？

> 1). 对于相同数量的数据集而言，AOF 文件通常要大于 RDB 文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。
> 2). 根据同步策略的不同，AOF 在运行效率上往往会慢于 RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和 RDB 一样高效。
>
> 二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行 save 的时候，再做备份（rdb）。rdb 这个就更有些 eventually consistent 的意思了。

------

## 写出 PHP 常用的语句

> - A 如何判断一个变量是否为空 empty ()
> - B 如何判断一个变量是否是 NULL is null
> - C 如何判断一个变量是否存在 isset ()
> - D 如何判断一个变量是否类型和值都等于 false 变量名 ===false
> - E 如何释放一个变量 unset ()
> - F 循环数组之前，检查数组 is_array ()

------

## PHP 中 error_reporting 函数的作用是什么？

> error_reporting ([int $level] ) — 设置应该报告何种 PHP 错误。

------

## 在 js 中我们经常使用 document.onload=function () 来实现文档载入后实现函数的调用，jquery 中也有和之相似的方法，是什么他们之间有什么异同？

\1. 执行时间

> - onload 指示页面包含图片等文件在内的所有元素都加载完成
> - ready () 表示文档结构已经加载完成（不包含图片等非文字媒体文件）。、

\2. 编写个数不同

> - onload 不能同时编写多个，如果有多个 onload 方法，只会执行一个
> - ready () 可以同时编写多个，并且都可以得到执行

\3. 简化写法

> - onload 没有简化写法
> - ready () 可以简写；

------

## PHP 读取计算机内存大的文件，该怎么操作？

> \1. 直接调用 linux 的 tail 命令来显示最 后几行
> \2. 简单粗暴，简单直接采用 file 函数来操作
> \3. 直接使用 php 的 fseek 来进行文件操作

------

## 实现中文字符串截取无乱码的方法，如何实现字符串反转？

```php
 function str_rev($str){
        //先判断参数是否为字符串，且为UTF8编码
        if(!is_string($str)||!mb_check_encoding($str,"utf-8")){
            die("输入的不是utf8类型的字符串");
        }
```

// 用 mb_strlen 函获取算 utf8 字符串的长度

```php
   $length=mb_strlen($str,"utf-8");
```

// 声明一个数组备用

```php
$arr=array();
    //将字符串拆开放入数组
        for($i=0;$i<$length;$i++){
            $arr[$i]=mb_substr($str,$i,1,"utf-8");
        }
```

// 将数组按键名大小反转

```php
   krsort($arr);

  //将数组中单个字符元素重新组合成字符串
        $str=implode("",$arr);
     //将翻转后的字符串返回
        return $str;
    }

  echo $s."<br>";
   echo str_rev($s);
```

------

## 写代码来解决多进程 / 线程同时读取一个文件的问题？

```php
  function T_put($filename,$string){
        //追加方式打开
        $fp = fopen($filename,'a');
        //加写锁
        if (flock($fp, LOCK_EX)){
            //写文件
            fputs($fp,$string);
            //解锁
            flock($fp, LOCK_UN);
        }
        fclose($fp);
    }
    function T_get($filename,$length){
        //追加方式打开
        $fp = fopen($filename,'r');
        //加读锁
        if (flock($fp, LOCK_SH)){
            //读取文件
            $result = fgets($fp,$length);
            //解锁
            flock($fp, LOCK_UN);
        }
        fclose($fp);
    }  
```

------

## 如何在 linux 系统中检查 mysql 服务是否启动？

> - 使用命令 # service mysqld status 或者 # service mysql status 命令来查看 mysql 的启动状态
> - 如果是 mysqld is stopped 那就说明 mysql 服务是停止状态，
> - 如果是 mysqld is running 那就说明 mysql 服务是启动状态

------

## Mysql 中值为空和值为 null 有什么区别？

> - 空值不一定为空
> - 空值是一个比较特殊的字段。在 MySQL 数据库中，在不同的情形下，空值往往代表不同的含义。这是 MySQL 数据库的一种特性。如在普通的字段中 (字符型的数据)，空值就是表示空值。但是如果将一个空值的数据插入到 TimesTamp 类型的字段中，空值就不一定为空
> - 空值 ('') 是不占用空间的
> - MySQL 中的 NULL 其实是占用空间的。

------

## Laravel 框架中依赖注入和控制反转的意义和作用？

> - 依赖注入就控制反转的一种是实现方式，面向对象的特征的重要体现 ，是我自身的，却是我需要的，都是我所依赖的。一切需要外部提供的，都是需要进行依赖注入的
> - 控制反转 是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection, DI）, 还有一种叫” 依赖查找”（Dependency Lookup）。
> - 通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。
> - 也就是说，我们需要一个调控系统，这个调控系统中我们存放一些对象的实体，或者对象的描述，在对象创建的时候将对象所依赖的对象的引用传递过去

------

## 数据库触发器和存储过程的实现方式和作用？

触发器：

> 1）触发器是一种特殊类型的存储过程，它由事件触发，而不是程序调用或手工启动，当数据库有特殊的操作时，这些操作由数据库中的事件来触发，自动完成这些 SQL 语句。
> 2 使用触发器可以用来保证数据的有效性和完整性，完成比约束更复杂的数据约束
> 3）触发器可以查询其他表，而且可以包含复杂的 SQL 语句。 它们主要用于强制服从复杂的业务规则或要求。 例如，您可以根据客户当前的帐户状态，控制是否允许插入新订单。
> 4）触发器也可用于强制引用完整性，以便在多个表中添加、更新或删除行时，保留在这些表之间所定义的关系。

作用：

> 1）触发器可通过数据库中的相关表实现级联更改；通过级联引用完整性约束可以更有效地执行这些更改。
> 2）触发器可以强制比用 CHECK 约束定义的约束更为复杂的约束。与 CHECK 约束不同，触发器可以引用其它表中的列。例如，触发器可以使用另一个表中的 SELECT 比较插入或更新的数据，以及执行其它操作，如修改数据或显示用户定义错误信息。
> 3）触发器还可以强制执行业务规则
> 4）触发器也可以评估数据修改前后的表状态，并根据其差异采取对策。

触发器 存储过程

> - 当某类数据操作 DML 语句发生时隐式地调用 从一个应用或过程中显示地调用
> - 在触发器体内禁止使用 COMMIT 和 ROLLBACK 语句 在过程体内可以使用所有 PL/SQL 块中都能使用的 SQL 语句，包括 COMMIT 和 ROLLBACK 语句
> - 不能接受参数输入 可以接受参数输入

------

## .foo () 和 @foo () 之间有什么区别？

> - foo () 会执行这个函式，任何解译错误、语法错误、执行错误都会在页面上显示出来。
> - @foo () 在执行这个函式时，会隐藏所有上述的错误讯息。
> - PHP 支持一个错误控制运算符：@。当将其放置在一个 PHP 表达式之前，该表达式可能产生的任何错误信息都被忽略掉。

------

## 有一个网页地址，比如 http://www.vogue.com.cn 如何得到它的内容？

> $str = file_get_contents(‘http://www.phpres.com/index.html’);
> file_put_contents

------

## .isset () 和 empty () 的区别？

> - PHP 的 isset () 函数 一般用来检测变量是否设置
> - PHP 的 empty () 函数 判断值为否为空

------

## 简述 mysql 的加锁机制？

mysql 锁能在并发情况下的 mysql 进行更好的优化

> MySQL 有三种锁的级别：页级、表级、行级，这 3 种锁的特性可大致归纳如下：
>
> - 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
> - 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
> - 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

共享锁

> 共享锁的代号是 S，是 Share 的缩写，共享多的锁粒度是行或者元组（多个行），一个事务获取了共享多之后，可以对锁定范围内的数据执行读操作。
> 排它锁
> 排它锁的代号是 X，是 eXclusive 的缩写，排他锁的粒度是行或元组，与共享锁相同，一个事务获取了排它锁之后，可以对锁定范围内的数据执行写操作。
> 意向锁
>
> - 意向锁是一种表锁，锁定的粒度是整张表，分为意向共享锁（IS）和意向排它锁（IX）两类。
> - 意向共享锁表示一个事务 “有意 “对数据上共享锁。“有意 “这两个字表达的意思比较微妙，说的明白点就是指事务想干这个事但还没有真去干。

锁的互斥和相容关系

> - 锁与锁之间的关系，要么相容，要么互斥
> - 锁 a 和锁 b 的相容是指：操作同样一组数据时，如果事务 t1 获取了锁 a，另一个事务 t2 还可以获取锁 b。
> - 锁 a 和锁 b 的互斥是指：操作同样一组数据时，如果事务 t1 获取了锁 a，另一个事务 t2 必须在 t1 释放锁 a 之后方可获取锁 b。

------

## 两台服务器之间快速拷贝文件方法？

> - 1.ftp
> - 2.samba 服务
> - 3.sftp
> - 4.scp

scp 本地用户名 @IP 地址：文件名 1 远程用户名 @IP 地址：文件名 2
[本地用户名 @IP 地址![:smirk:](https://cdn.learnku.com/assets/images/twemoji/smirk.png) 可以不输入，可能需要输入远程用户名所对应的密码.
可能有用的几个参数:

> - -v 和大多数 linux 命令中的 - v 意思一样，用来显示进度。可以用来查看连接，认证，或是配置错误.
> - -C 使能压缩选项.
> - -P 选择端口。注意 - p 已经被 rcp 使用.
> - -4 强行使用 IPV4 地址.
> - -6 强行使用 IPV6 地址.

------

## apache 服务器，查看并发数的命令？

```php
netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
```

## mysql 中 where 和 having 子句的区别？

> - Where 查询的字段数据表中有就可以，结果集中不显示也可以
> - Having 查询的字段必须在结果集中显示

作用的对象不同。

> - WHERE 子句作用于表和视图，HAVING 子句作用于组。
> - having 字句可以让我们筛选成组后的各种数据，
> - where 字句在聚合前先筛选记录，也就是说作用在 group by 和 having 字句前。
> - 而 having 子句在聚合后对组记录进行筛选。

------

## Redis 事务如何实现？跟 mysql 事务的区别？

> - redis 和 mysql 的区别非常大。
> - mysql 中一个中小型的网络数据库，比 oracle 和 sqlserver 小， 但是并发能力远超过 acess 这样的桌面数据库。
> - redis 是一个支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库。
> - 可以认为 redis 比 mysql 简化很多。
> - mysql 支持集群。
> - 现在大量的软件使用 redis 作为 mysql 在本地的数据库缓存，然后再适当的时候和 mysql 同步.

------

## 请写出 5 个以上 git 的命令及其用途，若不熟悉 git，可以写 svn 命令

> - git init 在哪一目录下，就会在该目录下生成.git 目录。
> - git status 查看本地库的状态
> - git add . 将所有发生改变的文件添加到暂存区
> - git commit -m 'git_initCommit' 将暂存区的文件实际保存到仓库的历史纪录.
> - git log 查看提交日志
> - git pull 取回远程仓库的变化，并与本地分支合并
> - .git clone + 项目的 url 该命令会把远程的库克隆到本地库目录下，与.git 目录同级
> - git remote –v 显示所有远程仓库
> - git push 推送所有分支到远程仓库

------

## Mysql 中覆盖索引指的是什么？

> 解释一： 就是 select 的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。
> 解释二： 索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。
> 解释三：是非聚集组合索引的一种形式，它包括在查询里的 Select、Join 和 Where 子句用到的所有列（即建立索引的字段正好是覆盖查询语句 [select 子句] 与查询条件 [Where 子句] 中所涉及的字段，也即，索引包含了查询正在查找的所有数据）。

------

## Session_id 和服务器 session 文件的关系？

> - session 的工作原理如下，即为 sessionid 在客户端和浏览器端的交互：
> - 当浏览器 A 去访问一个有打开了 session 机制的 php1 文件时，session 文件会创建，同时会将该 session 文件的 id 以 cookie 的形式
> - 发送给浏览器（session 文件的 id 号可以 session_id () 这个函数来获得）。当浏览器 A 没有关闭（会话没有结束），反而去访问另一个也开启
> - session 机制的 php2 文件时，那么该 sessionid 也会跟着 http 协议从浏览器发送到服务器上，访问到之前创建的 session 文件，将相
> - 关内存也保存到该 session 文件内。
> - 当我们开启了另一个浏览器 B，也就是创建了另一个会话，那么该浏览器访问一个带有开启 session 机制的网页，会另外生成一个新的 session 文件，并将该 session 文件 id 号以 cookie 的形式传递给浏览器 B.
> - 可以这么理解，一个会话对应一个 sessionid。

------

## Mysql count（1）和 count（*）的区别？

> - 如果你的数据表没有主键，那么 count (1) 比 count (*) 快
> - 如果有主键的话，那主键（联合主键）作为 count 的条件也比 count (*) 要快
> - 如果你的表只有一个字段的话那 count (*) 就是最快的啦
> - count (*) count (1) 两者比较。主要还是要 count (1) 所相对应的数据字段。
> - 如果 count (1) 是聚索引，id, 那肯定是 count (1) 快。但是差的很小的。
> - 因为 count (*), 自动会优化指定到那一个字段。所以没必要去 count (?)，用 count (*),sql 会帮你完成优化的

------

## 简述 php 中的 autoload？

> 在 PHP 中使用类时，我们必须在使用前加载进来，不管是通过 require 的方式还是 include 的方式，但是会有两个问题影响我们做出加载的决定 这时候我们可以使用魔术方法 Autoload 的加载机制，当通过 new 来实例化一个类时，PHP 会通过定义的 autoload 函数加载相应的文件，如果这个类文件使用了 extends 或者 implements 需要用到其他的类文件，php 会重新运行 autoload 去进行类文件的查找和加载，如果发生了两次对同一类文件的请求，就会报错

------

## 静态变量适用情况？有什么优缺点分别是什么？

> - static 方法是类中的一个成员方法，属于整个类，即使不用创建任何对象也可以直接调用！
>
> - 静态方法效率上要比实例化高，静态方法的缺点是不自动进行销毁，而实例化的则可以做销毁。
>
> - 静态方法和静态变量创建后始终使用同一块内存，而使用实例的方式会创建多个内存。
>
>   





https://learnku.com/articles/25204